<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通过 HeadScale(TailScale开源服务端) 多平台实现内网穿透</title>
    <link href="/2024/03/20/12-intranet-penetration-headscale/"/>
    <url>/2024/03/20/12-intranet-penetration-headscale/</url>
    
    <content type="html"><![CDATA[<h1 id="HeadScale-服务端搭建"><a href="#HeadScale-服务端搭建" class="headerlink" title="HeadScale 服务端搭建"></a>HeadScale 服务端搭建</h1><blockquote><p><a href="https://github.com/juanfont/headscale">HeadScale</a> 是一个开源的 TailScale 服务端实现，可以实现多平台的内网穿透。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><code>docker-compose.yaml</code> 文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.9&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">headscale:</span><br>    <span class="hljs-comment"># 镜像版本</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">headscale/headscale:0.23.0-alpha5</span><br>    <span class="hljs-comment"># 容器名称</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">headscale</span><br>    <span class="hljs-comment"># 挂载目录根据自己的需求进行修改（宿主机目录:容器目录）</span><br>    <span class="hljs-comment"># 其中 /headscale/config 为配置文件目录，/headscale/data 为数据目录，/headscale/run 为运行目录</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/headscale/config:/etc/headscale</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/headscale/data:/var/lib/headscale</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/headscale/run:/var/run/headscale</span><br>    <span class="hljs-comment"># 端口号根据自己的需求进行修改（宿主机端口:容器端口）</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br>    <span class="hljs-comment"># 此处最新版的命令行必须使用 server 命令，之前版本为 headscale serve</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">serve</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br></code></pre></td></tr></table></figure><p>创建目录及配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建宿主机挂载目录</span><br><span class="hljs-built_in">mkdir</span> -p /headscale/config<br><span class="hljs-built_in">mkdir</span> -p /headscale/data<br><span class="hljs-built_in">mkdir</span> -p /headscale/run<br><span class="hljs-built_in">cd</span> /headscale<br><br><span class="hljs-comment"># 创建配置文件（通过wget）</span><br>wget -O ./config/config.yaml https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml<br><span class="hljs-comment"># 或者通过curl</span><br>curl https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml -o ./config/config.yaml<br></code></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># config.yaml(此处就讲几个关键配置，其他基本不用修改)</span><br><span class="hljs-comment"># 修改 server_url 为你的域名</span><br><span class="hljs-attr">server_url:</span> <span class="hljs-string">https://proxy.your-domain.com/</span><br><br><span class="hljs-comment"># 监听地址（如果上边容器端口被修改此处也要修改）</span><br><span class="hljs-attr">listen_addr:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:8080</span><br><br><span class="hljs-comment"># 当 magic_dns 为 true 时，HeadScale 会自动为你的设备分配一个域名(也就是下边的base_domain，可以在内网环境访问，而不需要通过IP)</span><br><span class="hljs-attr">magic_dns:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">base_domain:</span> <span class="hljs-string">base_domain.com</span><br><br><span class="hljs-comment"># 随机化客户端端口</span><br><span class="hljs-attr">randomize_client_port:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>启动 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 docker-compose.yaml 所在目录下启动服务</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="WEB-UI管理工具"><a href="#WEB-UI管理工具" class="headerlink" title="WEB-UI管理工具"></a>WEB-UI管理工具</h2><blockquote><p>这类服务端一般都有一个 WEB-UI 管理工具，HeadScale 也不例外。</p><p>此处用 <a href="https://github.com/GoodiesHQ/headscale-admin">headscale-admin</a> 做演示，其他的管理工具也是类似的。</p></blockquote><p>使用 Docker 运行容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 宿主机端口随意</span><br>docker run -p 8000:80 goodieshq/headscale-admin:latest<br></code></pre></td></tr></table></figure><h2 id="反向代理配置"><a href="#反向代理配置" class="headerlink" title="反向代理配置"></a>反向代理配置</h2><p>在 Nginx 中配置反向代理，将 HeadScale 服务端的 8080 端口映射到 443 端口。想偷懒就直接通过面板管理工具添加一个反向代理。配置完毕记得重载 Nginx。其他WEB服务器也是类似的。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;<br>    <span class="hljs-comment"># 你的域名（自行修改）</span><br>    <span class="hljs-attribute">server_name</span> proxy.your-domain.com;<br><br>    <span class="hljs-comment"># 证书路径（自行修改）</span><br>    <span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/your-domain.com/fullchain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/your-domain.com/privkey.pem;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-comment"># 代理地址，如果上边映射的宿主机端口被修改此处也要修改</span><br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>    &#125;<br><br>    <span class="hljs-comment"># WEB-UI 管理工具, 访问地址为 https://proxy.your-domain.com/admin</span><br>    <span class="hljs-section">location</span> /admin &#123;<br>        <span class="hljs-comment"># 代理地址，如果上边映射的宿主机端口被修改此处也要修改</span><br>        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8000;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不出意外的话，HeadScale 服务端就搭建完成了。出意外就在下边留言吧。😊</p><p>现在就可以通过 <code>https://proxy.your-domain.com/admin</code> 访问 HeadScale 的 WEB-UI 页面了。</p><p>PS: 直接访问 <code>https://proxy.your-domain.com</code> 没效果。</p></blockquote><h2 id="WEB-UI-配置"><a href="#WEB-UI-配置" class="headerlink" title="WEB-UI 配置"></a>WEB-UI 配置</h2><p>首先，生成一个新的 API 密钥，然后将其添加到页面中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 HeadScale 服务端所在的宿主机上执行。执行完毕后会生成一个 API 密钥。</span><br>docker <span class="hljs-built_in">exec</span> -it headscale headscale apikeys create<br></code></pre></td></tr></table></figure><p>然后点击页面的保存按钮，出现左侧的菜单就算成功了。</p><p><img src="https://image.origin-tec.com/origin/2024/03/20/65fa99353a468.jpg" alt="HeadScale-Admin"></p><h1 id="TailScale-客户端配置"><a href="#TailScale-客户端配置" class="headerlink" title="TailScale 客户端配置"></a>TailScale 客户端配置</h1><blockquote><p>下载并安装 <a href="https://tailscale.com/download">TailScale</a> 客户端。</p></blockquote><p>在 WEB-UI 这里添加用户，然后生成一个临时的key，后边要用到。</p><p><img src="https://image.origin-tec.com/origin/2024/03/20/65fa9ab874689.jpg" alt="添加用户"></p><p><img src="https://image.origin-tec.com/origin/2024/03/20/65fa9b92abd4c.jpg" alt="生成PreAuthKey"></p><p>然后根据你当前设备平台，选择安装不同的客户端。<strong>要修改 URL 为你的 HeadScale 服务端域名。</strong></p><h2 id="Linux-客户端部署"><a href="#Linux-客户端部署" class="headerlink" title="Linux 客户端部署"></a>Linux 客户端部署</h2><p>此处以 CentOS 为例（参考官方文档）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 已经是 root 用户就不用输入 sudo 了。</span><br>sudo dnf config-manager --add-repo https://pkgs.tailscale.com/stable/centos/8/tailscale.repo<br>sudo dnf install tailscale<br><br>sudo systemctl <span class="hljs-built_in">enable</span> --now tailscaled<br></code></pre></td></tr></table></figure><p>主要是后续步骤不同，这里打开 WEB-UI 页面，选择 Deploy，复制生成的命令行：</p><p><img src="https://image.origin-tec.com/origin/2024/03/20/65fa9d456ebe5.jpg" alt="deploy"></p><blockquote><p>如果只需要通过内网IP进行访问，就不需要勾选 –accept-dns 了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在你的设备上执行（此处仅作为参考，根据实际情况修改）</span><br>tailscale up --login-server=https://proxy.your-domain.com --reset --authkey=xxx --accept-dns --accept-routes<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看状态</span><br>tailscale status<br></code></pre></td></tr></table></figure><p>然后现在客户端就部署成功了，可以通过内网IP进行访问了。其他平台的部署参考官方文档，也是类似的。<br>例如：<a href="https://github.com/juanfont/headscale/blob/main/docs/android-client.md">Android</a>、<a href="https://github.com/juanfont/headscale/blob/main/docs/iOS-client.md">iOS</a>、<a href="https://github.com/juanfont/headscale/blob/main/docs/windows-client.md">Windows</a> 等。</p><p>客户端提供很多功能，例如可以通过内网传输文件、远程桌面、远程调试等，另外还可以通过公网服务器反向代理访问内网服务器，用于数据处理等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 部署了多台设备之后，可以通过Ping测试一下(此处修改为你需要PING的设备内网IP)</span><br>tailscale ping xxx.xxx.xxx.xxx<br></code></pre></td></tr></table></figure><p>当然，如果你可能发现访问速度可能会有点慢，可以通过配置 Derp 中继服务器来解决，可以快速打洞，如果不成功也能进行兜底。</p><h1 id="Derp-服务端部署"><a href="#Derp-服务端部署" class="headerlink" title="Derp 服务端部署"></a>Derp 服务端部署</h1><p>可参考 <a href="https://github.com/fredliang44/derper-docker">derper-docker</a>，docker-compose.yaml 文件如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.5&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">derper:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">derper</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">fredliang/derper</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># 此处修改为你的证书目录（例如letsencrypt的证书，目录需要包含fullchain.pem、privkey.pem 等文件）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./cert:/cert</span><br>      <span class="hljs-comment"># handscale.sock</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;headscale/run/handscale.sock:/var/run/tailscale/tailscaled.sock:ro&#x27;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># 记得防火墙开放端口（云服务器同样）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">3478</span><span class="hljs-string">:3478/udp</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">23479</span><span class="hljs-string">:23479</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-comment"># 此处修改为你的域名</span><br>      <span class="hljs-attr">DERP_DOMAIN:</span> <span class="hljs-string">derp.your-domain.com</span><br>      <span class="hljs-comment"># 端口号根据自己的需求进行修改</span><br>      <span class="hljs-attr">DERP_ADDR:</span> <span class="hljs-string">&#x27;:23479&#x27;</span><br>      <span class="hljs-comment"># 此处修改为你的证书目录</span><br>      <span class="hljs-attr">DERP_CERT_DIR:</span> <span class="hljs-string">/cert</span><br>      <span class="hljs-comment"># 证书模式（这里请参考上边的 derper-docker）</span><br>      <span class="hljs-attr">DERP_CERT_MODE:</span> <span class="hljs-string">&#x27;letsencrypt&#x27;</span><br></code></pre></td></tr></table></figure><p>运行 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 docker-compose.yaml 所在目录下启动服务</span><br>docker-compose up -d<br></code></pre></td></tr></table></figure><p>然后设置反向代理，例如把你的 <code>derp.your-domain.com</code> 代理到 <code>127.0.0.1:23479</code>，https协议，此处不再赘述。</p><p>此时访问你的 <code>https://derp.your-domain.com</code> 页面会显示相关信息，说明部署成功了。</p><p>配置完毕后在 <code>config.yaml</code> 所在目录 <code>/headscale/config</code> 下添加 <code>derp.yaml</code> 文件，并修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># derp.yaml</span><br><span class="hljs-comment"># If you plan to somehow use headscale, please deploy your own DERP infra: https://tailscale.com/kb/1118/custom-derp-servers/</span><br><span class="hljs-attr">regions:</span><br>  <span class="hljs-attr">900:</span><br>    <span class="hljs-attr">regionid:</span> <span class="hljs-number">900</span><br>    <span class="hljs-attr">regioncode:</span> <span class="hljs-string">地域代码</span><br>    <span class="hljs-attr">regionname:</span> <span class="hljs-string">地域名称</span><br>    <span class="hljs-attr">nodes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">900a</span><br>        <span class="hljs-attr">regionid:</span> <span class="hljs-number">900</span><br>        <span class="hljs-attr">hostname:</span> <span class="hljs-string">derp.your-domain.com</span><br>        <span class="hljs-attr">ipv4:</span> <span class="hljs-string">你的公网IP</span><br>        <span class="hljs-attr">stunport:</span> <span class="hljs-number">3478</span><br>        <span class="hljs-attr">stunonly:</span> <span class="hljs-literal">false</span><br>        <span class="hljs-attr">derpport:</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>修改 HeadScale 服务端的配置文件，添加 Derp 配置路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># config.yaml</span><br><span class="hljs-attr">derp:</span> <br> <span class="hljs-comment"># 将默认的 DERP 服务器注释掉</span><br> <span class="hljs-attr">urls:</span><br>    <span class="hljs-comment"># - https://controlplane.tailscale.com/derpmap/default</span><br> <span class="hljs-comment"># 自定义 DERP 服务器路径</span><br> <span class="hljs-attr">paths:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/headscale/derp.yaml</span><br></code></pre></td></tr></table></figure><p>配置完毕后通过 <code>docker restart</code> 重启 HeadScale 服务端。再然后在客户端重新运行 tailscale 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tailscale down<br>tailscale up <br></code></pre></td></tr></table></figure><p>网络检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tailscale netcheck<br></code></pre></td></tr></table></figure><p>如果展示如下信息，说明配置成功了。</p><p><img src="https://image.origin-tec.com/origin/2024/03/20/65faa8911f9cf.jpg" alt="derp"></p><p>现在，内网穿透就配置完成了，可以通过公网IP访问内网服务器了，速度也会提升巨大。</p><p><strong>Enjoy it! 🎉</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/juanfont/headscale">HeadScale Git</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://github.com/GoodiesHQ/headscale-admin">headscale-admin Git</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://tailscale.com/">TailScale Website</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://github.com/fredliang44/derper-docker">Derper-Docker</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网穿透</tag>
      
      <tag>headscale</tag>
      
      <tag>tailscale</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hi工大Pro项目前端技术细节解析</title>
    <link href="/2022/09/16/11-hi-miniprogram/"/>
    <url>/2022/09/16/11-hi-miniprogram/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote><p><a href="https://hi-plus.windstormlab.com/">Hi工大Pro</a> 是一款服务于大学生的校园生活平台，使用人数达到数万人，用户粘性较高，深受广大用户喜爱。该项目包含论坛社交、今日课表、查课表、查成绩、查空教室、失物招领、寻物启事、校园天气查询等一系列功能，并全局适配暗黑主题，支持更换主题配色。可以扫码体验，包含微信和QQ小程序。</p></blockquote><p><img src="https://image.origin-tec.com/img/c67e6379ad706b4237c6a27f52ab5ff9@860x860.jpg?x-oss-process=image/resize,w_256,h_256,m_fixed" alt="微信小程序"></p><p><img src="https://image.origin-tec.com/img/1a7172ada8fbfb0aa35b1440b011e812@580x580.png?x-oss-process=image/resize,w_256,h_256,m_fixed" alt="QQ小程序"></p><h1 id="技术相关"><a href="#技术相关" class="headerlink" title="技术相关"></a>技术相关</h1><blockquote><p>本人作为该项目团队技术负责人，负责该项目技术栈架构选型、前后端开发、项目部署、代码规范约束、项目UI设计等工作。其中该项目80%前端开发及95%后端开发均由本人独立完成。</p></blockquote><h2 id="前端技术架构"><a href="#前端技术架构" class="headerlink" title="前端技术架构"></a>前端技术架构</h2><h3 id="版本迭代"><a href="#版本迭代" class="headerlink" title="版本迭代"></a>版本迭代</h3><h4 id="V1-x-V2-x-2020-3-2021-9"><a href="#V1-x-V2-x-2020-3-2021-9" class="headerlink" title="V1.x ~ V2.x (2020.3 ~ 2021.9)"></a>V1.x ~ V2.x (2020.3 ~ 2021.9)</h4><p>该版本前端技术栈采用的是原生小程序，通过Gitee平台进行项目代码管理，有代码相应规范，但未采取统一的集成部署，仍是手动打包上传至微信再手动提交审核。</p><p>该版本迭代优化后，包含今日课表、查课表、查成绩、查空教室、绩点预警、等级考试、竞赛通知、校园天气、社团组织、校车校历、失物招领、寻物启事、趣玩（趣定向打卡功能）、趣跑（实现了小程序端的在线跑步，包含运动轨迹地图、速度卡路里标注、在线排行榜）等相应功能。</p><h4 id="V3-x-（2021-9-至今）"><a href="#V3-x-（2021-9-至今）" class="headerlink" title="V3.x （2021.9 ~ 至今）"></a>V3.x （2021.9 ~ 至今）</h4><p>后续应项目需要，为实现多平台部署，降低开发成本（如打包为Android和iOS应用）。遂采取UniApp框架对项目进行重构优化（可以实现多平台部署），并加入了 <strong>node_modules包管理</strong> 和 <strong>Jenkins集成部署</strong>。该项目于2021年9月底大部分重构完毕后，统一部署至微信和QQ小程序端。</p><p>该版本主要加入了论坛社交模块，支持手机号、微信、QQ登录，且支持多校园多系统（后端实现了多个教务系统的爬虫）适配，并迭代掉了非必要的社团组织、等级考试、竞赛通知、趣玩、趣跑等功能。</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="https://image.origin-tec.com/img/daec55b4f48bd0e728e525fd100ecd3b@251x796.png" alt="项目结构"></p><p>该项目使用 Yarn 作为包管理工具。其中最重要的是 src 目录下的一系列文件，如:</p><ul><li>assets、static: 静态文件，如 css 及 图片 等</li><li>ci: 包含微信及QQ小程序的集成部署相关操作</li><li>components: 项目中引入的组件，包含自定义封装组件与外部组件库等。</li><li>pages: 项目页面相关源代码</li><li>private-key: 继承部署验证需要的私钥文件</li><li>utils: 项目需要的一些工具类库等</li></ul><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><h4 id="如何实现的暗黑主题（多配色）适配？"><a href="#如何实现的暗黑主题（多配色）适配？" class="headerlink" title="如何实现的暗黑主题（多配色）适配？"></a>如何实现的暗黑主题（多配色）适配？</h4><p>一般来说，暗黑主题适配有两种方案 : </p><ul><li>根据 css 中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme">媒体查询</a>，@media(prefers-color-scheme<br>: dark )</li><li>通过调用API获取系统中的当前主题再做出相应css修改。</li></ul><p>我们这个项目采取的是第二种方法，那么为什么不采取第一种方案呢？不是更方便一些吗，甚至都不需要写JS层面的代码。</p><p>首先我们应该知道如果通过媒体查询进行适配暗黑主题色，那么当前应用的主题色只能和系统保持一致，而无法被用户通过应用内的设置做出相应的修改。</p><p>而如果当我们采取API获取系统主题方式，可以让用户选择是否跟随系统主题，获取应用内独立设置当前主题配色。</p><p>可以看下项目中该部分代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">loadTheme</span> = (<span class="hljs-params">that, isSetFrontColor = <span class="hljs-literal">true</span>, setTabbar = <span class="hljs-literal">false</span></span>) =&gt;  &#123;<br>    <span class="hljs-comment">// 其中 that 指向的是调用loadTheme函数的指定应用实例</span><br>    <span class="hljs-comment">// isSetFrontColor 表示是否需要设置前景色</span><br>    <span class="hljs-comment">// setTabbar 表示是否需要修改tabbar的主题色</span><br>     uni.<span class="hljs-title function_">setBackgroundColor</span>(&#123;<br>       <span class="hljs-attr">backgroundColor</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">navbarColor</span>,<br>     &#125;);<br>     <span class="hljs-keyword">if</span> (isSetFrontColor || <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;dark&quot;</span>) &#123;<br>       uni.<span class="hljs-title function_">setNavigationBarColor</span>(&#123;<br>         <span class="hljs-attr">frontColor</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">statusColor</span>,<br>         <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>       &#125;);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;light&quot;</span>) &#123;<br>         uni.<span class="hljs-title function_">setNavigationBarColor</span>(&#123;<br>           <span class="hljs-attr">frontColor</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>           <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;#ffffff&quot;</span>,<br>         &#125;);<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">navbarColor</span> === <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">navbarColor</span> =<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">backgroundColor</span>;<br>     &#125;<br>     <span class="hljs-keyword">let</span> themeType = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">type</span>;<br>     <span class="hljs-keyword">let</span> currentType = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">tabbar</span>.<span class="hljs-property">current</span>;<br><br>     <span class="hljs-keyword">if</span> (setTabbar) &#123;<br>       <span class="hljs-keyword">let</span> list = [];<br>       <span class="hljs-keyword">let</span> length = list.<span class="hljs-property">length</span>;<br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">tabbar</span>.<span class="hljs-property">current</span> = themeType;<br>       <span class="hljs-keyword">if</span> (themeType === <span class="hljs-string">&quot;dark&quot;</span>) &#123;<br>         uni.<span class="hljs-title function_">setTabBarStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">tabbar</span>.<span class="hljs-property">dark</span>);<br>         list = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">tabbar</span>.<span class="hljs-property">dark</span>.<span class="hljs-property">list</span>;<br>         length = list.<span class="hljs-property">length</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         uni.<span class="hljs-title function_">setTabBarStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">tabbar</span>.<span class="hljs-property">light</span>);<br>         list = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">tabbar</span>.<span class="hljs-property">light</span>.<span class="hljs-property">list</span>;<br>         length = list.<span class="hljs-property">length</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>         <span class="hljs-comment">// 对 tabbar中的每一个 item 进行遍历，并调用 setTabBarItem API进行相应修改</span><br>         uni.<span class="hljs-title function_">setTabBarItem</span>(&#123;<br>           <span class="hljs-attr">index</span>: i,<br>           ...list[i],<br>         &#125;);<br>       &#125;<br>     &#125;<br>     <span class="hljs-comment">// 此处主题色保存在全局遍历 theme 中</span><br>     (that.<span class="hljs-property">themeType</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">type</span>),<br>       (that.<span class="hljs-property">statusColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">statusColor</span>),<br>       (that.<span class="hljs-property">navFontColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">navFontColor</span>),<br>       (that.<span class="hljs-property">fontColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">fontColor</span>),<br>       (that.<span class="hljs-property">navbarColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">navbarColor</span>),<br>       (that.<span class="hljs-property">bgColorTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">navbarColor</span>),<br>       (that.<span class="hljs-property">bgImage</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">bgImage</span>),<br>       (that.<span class="hljs-property">scheduleBgImage</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">scheduleBgImage</span>),<br>       (that.<span class="hljs-property">homeBgImage</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">homeBgImage</span>),<br>       (that.<span class="hljs-property">appImages</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">globalData</span>.<span class="hljs-property">appImages</span>);<br>   &#125;,<br></code></pre></td></tr></table></figure><p>然后在指定页面实例中（如pages&#x2F;index&#x2F;index.vue），我们会在 onLoad 这个Hook函数中调用全局提供的 loadTheme 函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此处 app 通过 getApp() 获取的，指向的是全局实例。</span><br><span class="hljs-keyword">if</span> (app.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">ready</span>) &#123;<br>app.<span class="hljs-title function_">loadTheme</span>(<span class="hljs-variable language_">this</span>, app.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;dark&quot;</span>, <span class="hljs-literal">true</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 为什么需要这个 callback 回调呢？</span><br>    <span class="hljs-comment">// 因为主题色配置 app.globalData.theme 是在 localstorage 中读取的，而 onLoad 钩子函数触发的事件不一定在配置内容读取完毕之后发生。</span><br>    <span class="hljs-comment">// 所以需要一个ready的判断，如果未完成读取，则增加一个回调，等待读取完毕后直接调用</span><br>    app.<span class="hljs-property">themeReadyCallback</span> = <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        app.<span class="hljs-title function_">loadTheme</span>(<span class="hljs-variable language_">this</span>, app.<span class="hljs-property">globalData</span>.<span class="hljs-property">theme</span>.<span class="hljs-property">type</span> == <span class="hljs-string">&quot;dark&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 loadTheme 调用完毕后，页面上会发生什么呢？ -&gt; 主题会被改变</p><p>主题是如何被改变的呢，这里可以参考以下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#x27;theme-&#x27; + themeType&quot;</span>&gt;</span><br>        所有的pages页面最外层均会包含一个 themeType主题类型的变量。<br>        通过修改这个变量再结合Vue的响应式原理，通知到使用到这个变量的地方进行相应修改。<br>        然后根据不同的 class 类选择器，页面则会渲染不同的样式。<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>公共暗黑主题样式（assets&#x2F;css&#x2F;theme-dark.less）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.theme-dark</span>&#123;<br><span class="hljs-selector-tag">input</span>,<span class="hljs-selector-tag">textarea</span>&#123;<br><span class="hljs-attribute">color</span>:var(--theme-dark-font)<span class="hljs-meta">!important</span>;<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实还涉及到主题配置项读取的函数及主题配色修改页面的一些函数，但内容过多，就不过于赘述了。</p><h4 id="项目图片懒加载是如何实现的？"><a href="#项目图片懒加载是如何实现的？" class="headerlink" title="项目图片懒加载是如何实现的？"></a>项目图片懒加载是如何实现的？</h4><p>这个项目中的绝大部分图片（例如论坛动态中的图片、头像等）都用组件进行封装，并加入了图片懒加载，避免一次性加载完毕，缓解CDN的压力。</p><p>有的可能看到就觉得，图片懒加载还不简单，我倒着都能写！</p><p>其实差不多是这样，技术含量不高，但存在让我们思考的细节。</p><!-- 我这里也能提供三种实现图片懒加载的方案： --><p><strong>未完待续</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hi工大Pro</tag>
      
      <tag>自研项目</tag>
      
      <tag>小程序</tag>
      
      <tag>前端技术</tag>
      
      <tag>UniApp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web Tracking 前端埋点技术探究</title>
    <link href="/2022/07/25/10-web-tracking/"/>
    <url>/2022/07/25/10-web-tracking/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Web Tracking（此处细分来说应该叫 Web beacon）。Web beacon 是一种在网页和电子邮件上使用的技术，可以不显眼地（通常是无形的）检查用户是否访问了某些内容。Web beacon 通常由第三方用于监控用户在网站上的活动，以进行网络分析或页面标记。它们也可用于电子邮件跟踪。当使用JavaScript实现时，它们可以被称为JavaScript标签。<br>使用此类信标，公司和组织可以跟踪网络用户的在线行为。起初，进行此类跟踪的公司主要是广告商或网络分析公司;后来的社交媒体网站也开始使用这种跟踪技术，例如通过使用充当跟踪信标的按钮。<br>2017年，W3C发布了Web开发人员可用于创建Web信标的接口的候选规范。</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="lt-img-gt"><a href="#lt-img-gt" class="headerlink" title="&lt;img&gt;"></a><code>&lt;img&gt;</code></h3><blockquote><p>例如如果我们发送邮件后，想知道对方是否已读，就需要在邮件中嵌入一张图片，我们发送的get请求即是图片的src。当我们收到这次get请求后，在接口中写下逻辑处理函数等，处理完毕需要返回一张图片（通常情况下是一张1x1的GIF图片）。</p></blockquote><p>例如嵌入在 HTML 中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://api.toflying.com/report?from=test&amp;id=123&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>又或者嵌入到 JavaScript 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()<br>image.<span class="hljs-property">src</span> =  <span class="hljs-string">&quot;http://api.toflying.com/report?from=test&amp;id=123&quot;</span><br><span class="hljs-comment">// 这里不需要 appendChild 插入到页面中只需设置src属性即可发送Get请求。</span><br></code></pre></td></tr></table></figure><p>上面的 <code>http://api.toflying.com/report?from=test&amp;id=123</code> 就是API GET请求的URL，当然真实情况下是不存在的。我们可以携带任意参数（例如来源的平台、当前文章的ID等），并可以在后端处理相应逻辑。</p><p><strong>那么问题来了，为什么要用 <code>&lt;img&gt;</code> 标签？</strong></p><p>那是因为，我们的 <code>&lt;img&gt;</code> 相当于一次 <strong>GET</strong> 请求，并且<strong>没有跨域</strong>的限制。正是因为没有跨域限制，所以我们可以在任意网站（或者在我们发送的邮件中）嵌入该标签。这样我们就可以知道这些网站页面或者邮件被人阅读的情况，甚至可以分析对方的设备、IP、意图等等。</p><p><strong>那为什么一定要返回一张图片？</strong></p><p>如果我们返回的是一段文本或者说是JSON字符串（返回头中的 content-type: application&#x2F;json;）。<code>&lt;img&gt;</code> 标签会触发 onerror 事件，会报错。如果返回空的话也会报CORB的问题，然后页面上的那张图片也会裂开（如果标签存在的话）。所以我们通常返回一张图片（返回头为content-type: image&#x2F;*）。</p><p><strong>为什么图片是 1x1 GIF 图片？</strong></p><p>在同样尺寸下，不同格式的图片GIF格式占用的存储空间是最小的，也可以降低服务器的传输压力。</p><h3 id="navigator-sendBeacon"><a href="#navigator-sendBeacon" class="headerlink" title="navigator.sendBeacon"></a><code>navigator.sendBeacon</code></h3><blockquote><p><code>navigator.sendBeacon()</code> 方法可用于通过 HTTP <strong>POST</strong> 将少量数据 异步 传输到 Web 服务器。它主要用于将统计数据发送到 Web 服务器，同时避免了用传统技术（如：XMLHttpRequest）发送分析数据的一些问题。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">navigator.<span class="hljs-title function_">sendBeacon</span>(url, data);<br></code></pre></td></tr></table></figure><p>其中：url 是 POST 请求的地址。而 data 可选，是请求附带的数据（ ArrayBuffer、ArrayBufferView、Blob、DOMString、FormData 或 URLSearchParams）</p><p>当用户代理成功把数据加入传输队列时，<code>sendBeacon()</code> 方法将会返回 <code>true</code>，否则返回 <code>false</code>。</p><p>相较于图片的src，这种方式的更有优势：</p><ul><li>不会和主要业务代码抢占资源，而是在浏览器空闲时去做发送；</li><li>并且在页面卸载时也能保证请求成功发送，不阻塞页面刷新和跳转；</li></ul><p>现在的埋点监控工具通常会优先使用sendBeacon，但由于浏览器兼容性，还是需要用图片的src兜底。</p><p>用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;http://api.toflying.com/report&quot;</span><br><span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>data.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)<br>data.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>)<br>navigator.<span class="hljs-title function_">sendBeacon</span>(url, data)<br></code></pre></td></tr></table></figure><p>当然，在实际使用中也没有这么简单。</p><p>过去，许多网站使用 <code>unload</code> 或 <code>beforeunload</code> 事件以在会话结束时发送统计数据。然而这是不可靠的，在许多情况下（尤其是移动设备）浏览器不会产生 <code>unload</code>、<code>beforeunload</code> 或 <code>pagehide</code> 事件。下面列出了一种不触发上述事件的情况：</p><ul><li>用户加载了网页并与其交互。</li><li>完成浏览后，用户切换到了其它应用程序，而不是关闭选项卡。</li><li>随后，用户通过手机的应用管理器关闭了浏览器应用。</li></ul><p>此外，<code>unload</code> 事件与现代浏览器实现的往返缓存（bfcache）不兼容。在部分浏览器（如：Firefox）通过在 bfcache 中排除包含 <code>unload</code> 事件处理器的页面来解决不兼容问题，但这存在性能损失。</p><p>其它浏览器，例如 Safari 和 Android 上的 Chrome 浏览器则采取用户在同一标签页下导航至其它页面时不触发 <code>unload</code> 事件的方法来解决不兼容问题。</p><p>Firefox 也会在 bfcache 中排除包含 <code>beforeunload</code> 事件处理器的页面。</p><p>在会话结束时发送统计数据<br>网站通常希望在用户完成页面浏览后向服务器发送分析或诊断数据，最可靠的方法是在 <code>visibilitychange</code> 事件发生时发送数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">report</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&#x27;hidden&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;http://api.toflying.com/report&quot;</span><br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()<br>    data.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)<br>    data.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>)<br>    navigator.<span class="hljs-title function_">sendBeacon</span>(url, data)<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>可使用 <code>pagehide</code> 件来代替部分浏览器未实现的 <code>visibilitychange</code> 事件。和 <code>beforeunload</code> 与 <code>unload</code> 事件类似，这一事件不会被可靠地触发（特别是在移动设备上），但它与 <code>bfcache</code> 兼容。</p><p><strong>浏览器兼容性</strong></p><p><img src="https://image.origin-tec.com/img/af53a3d7d4a46f5f9f373ad6ed2703ba@798x357.png" alt="浏览器兼容性"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常 <code>&lt;img&gt;</code> 标签出现的需要跨域的场景中。而 <code>navigator.sendBeacon</code> 可以在自己网站使用，当然如果使用不了（例如IE浏览器）可以用 <code>&lt;img&gt;</code>。</p><p><strong>未完待续</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Web_tracking">Web Tracking - Wikipedia</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon">Navigator.sendBeacon - Web API 接口参考 | MDN</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>WebTracking</tag>
      
      <tag>WebBeacon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过requestAnimationFrame实现一个定时器</title>
    <link href="/2022/07/19/9-requestAnimationFrame-api/"/>
    <url>/2022/07/19/9-requestAnimationFrame-api/</url>
    
    <content type="html"><![CDATA[<h2 id="MDN解释"><a href="#MDN解释" class="headerlink" title="MDN解释"></a>MDN解释</h2><p><code>window.requestAnimationFrame()</code> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p><blockquote><p>备注： 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 <code>window.requestAnimationFrame()</code></p></blockquote><p>当你准备更新动画时你应该调用此方法。这将使浏览器在下一次重绘之前调用你传入给该方法的动画函数 (即你的回调函数)。回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。</p><p>另外为了提高性能和电池寿命，在大多数浏览器里，当 <code>requestAnimationFrame()</code> 运行在后台标签页或者隐藏的 <code>&lt;iframe&gt;</code> 里时，<code>requestAnimationFrame()</code> 会被暂停调用以提升性能和电池寿命。</p><p>回调函数会被传入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp">DOMHighResTimeStamp</a> 参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp">DOMHighResTimeStamp</a> 指示当前被 <code>requestAnimationFrame()</code> 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为 1ms(1000μs)。</p><div class="note note-warning">            <p><strong>提醒：</strong> 请确保总是使用第一个参数 (或其它获得当前时间的方法) 计算每次调用之间的时间间隔，否则动画在高刷新率的屏幕中会运行得更快。请参考下面例子的做法。  </p>          </div><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(callback);<br></code></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>callback</code></p><p>下一次重绘之前更新动画帧所调用的函数 (即上面所说的回调函数)。该回调函数会被传入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp">DOMHighResTimeStamp</a> 参数，该参数与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance/now">performance.now()</a> 的返回值相同，它表示 <code>requestAnimationFrame()</code> 开始去执行回调函数的时刻。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 <code>window.cancelAnimationFrame()</code> 以取消回调函数。</p><h2 id="定时器实现"><a href="#定时器实现" class="headerlink" title="定时器实现"></a>定时器实现</h2><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setMyInterval</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> requestAnimationFrame = <span class="hljs-variable language_">window</span>.<span class="hljs-property">requestAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozRequestAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitRequestAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">msRequestAnimationFrame</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><br>    options.<span class="hljs-property">timer</span> = options.<span class="hljs-property">timer</span> || <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">loop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        options.<span class="hljs-property">timer</span> = <span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">60</span> === <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 此处 60 代表屏幕刷新率为60HZ，即代表此处每隔一秒执行一次</span><br>            timeout = options.<span class="hljs-property">timeout</span> || <span class="hljs-number">1000</span><br>            <span class="hljs-keyword">if</span>(count % <span class="hljs-built_in">parseInt</span>(timeout / <span class="hljs-number">1000</span>) === <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">// 每隔多少秒调用一次回调函数，此处timeout应为1000的倍数</span><br>                options.<span class="hljs-property">callback</span> &amp;&amp; options.<span class="hljs-title function_">callback</span>()<br>            &#125;<br>            count++<br>        &#125;<br>        i++<br>    &#125;<br>    options.<span class="hljs-property">timer</span> = <span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">setMyTimeout</span> = (<span class="hljs-params">options</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> requestAnimationFrame = <span class="hljs-variable language_">window</span>.<span class="hljs-property">requestAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozRequestAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkitRequestAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">msRequestAnimationFrame</span><br>    <span class="hljs-keyword">const</span> cancelAnimationFrame = <span class="hljs-variable language_">window</span>.<span class="hljs-property">cancelAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozCancelAnimationFrame</span><br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">1</span><br>    options.<span class="hljs-property">timer</span> = options.<span class="hljs-property">timer</span> || <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">loop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        options.<span class="hljs-property">timer</span> = <span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>        <span class="hljs-keyword">if</span>(i % <span class="hljs-number">60</span> === <span class="hljs-number">0</span>)&#123;<br>            timeout = options.<span class="hljs-property">timeout</span> || <span class="hljs-number">1000</span><br>            <span class="hljs-keyword">if</span>(count % <span class="hljs-built_in">parseInt</span>(timeout / <span class="hljs-number">1000</span>) === <span class="hljs-number">0</span>)&#123;<br>                options.<span class="hljs-property">callback</span> &amp;&amp; options.<span class="hljs-title function_">callback</span>()<br>                <span class="hljs-title function_">cancelAnimationFrame</span>(options.<span class="hljs-property">timer</span>)<br>            &#125;<br>            count++<br>        &#125;<br>        i++<br>    &#125;<br>    options.<span class="hljs-property">timer</span> = <span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="clearInterval-x2F-clearTimeout"><a href="#clearInterval-x2F-clearTimeout" class="headerlink" title="clearInterval &#x2F; clearTimeout"></a>clearInterval &#x2F; clearTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">clearMyInterval</span> = (<span class="hljs-params">timer</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> cancelAnimationFrame = <span class="hljs-variable language_">window</span>.<span class="hljs-property">cancelAnimationFrame</span> || <span class="hljs-variable language_">window</span>.<span class="hljs-property">mozCancelAnimationFrame</span><br>    <span class="hljs-title function_">cancelAnimationFrame</span>(timer)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> options = &#123;<br>    <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span><br>&#125;<br><br>options.<span class="hljs-property">timeout</span> = <span class="hljs-number">3000</span><br><br>options.<span class="hljs-property">callback</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toLocaleString</span>())<br>&#125;<br><br><span class="hljs-title function_">setMyInterval</span>(options)<br><br><span class="hljs-title function_">setMyTimeout</span>(&#123;<br>  <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">callback</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setMyTimeout&#x27;</span>)<br>    <span class="hljs-title function_">clearMyInterval</span>(options.<span class="hljs-property">timer</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;cancel&quot;</span>)<br>  &#125;,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">6000</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="在线示例"><a href="#在线示例" class="headerlink" title="在线示例"></a>在线示例</h3><p><a href="https://codepen.io/kingcheni/pen/ZExeKyQ?editors=0012">CodePen.io</a></p><h2 id="题外话：如何通过JS获取屏幕帧数"><a href="#题外话：如何通过JS获取屏幕帧数" class="headerlink" title="题外话：如何通过JS获取屏幕帧数"></a>题外话：如何通过JS获取屏幕帧数</h2><div class="note note-primary">            <p>我们知道循环调用<code>requestAnimationFrame</code> 其频率<strong>通常情况下</strong>会和屏幕帧数保持一致，所以这个其实我们也可以通过 <code>requestAnimationFrame</code> 来实现。</p>          </div><p><strong>代码如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getScreenFrames</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> startTime = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> endTime = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br>    (<span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<br>      timer = <span class="hljs-title function_">requestAnimationFrame</span>(loop);<br>      startTime = startTime === <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() : startTime;<br>      endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();<br>      <span class="hljs-keyword">if</span> (endTime - startTime &gt; <span class="hljs-number">1000</span>) &#123;<br>        <span class="hljs-title function_">cancelAnimationFrame</span>(timer);<br>        <span class="hljs-title function_">resolve</span>(i - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      i++;<br>    &#125;)();<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="在线示例-1"><a href="#在线示例-1" class="headerlink" title="在线示例"></a>在线示例</h3><div id="app">  <span class="fps" style="font-size: 18px;line-height: 60px;">FPS: Loading...</span>（这个是实时变化的~）</div><p><a href="https://codepen.io/kingcheni/pen/yLKbaNv">CodePen.io</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><script src="../../../../js/getScreenFrame.js"></script><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">window.requestAnimationFrame - Web API 接口参考 | MDN</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>定时器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写一个Vue双向绑定实现的Demo</title>
    <link href="/2022/07/14/8-vue-demo/"/>
    <url>/2022/07/14/8-vue-demo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在 <a href="https://toflying.com/2022/07/08/6-talk-about-es6-proxy/">浅谈 ES6 中的 Proxy 用法</a> 中我们提到，在 Vue2 中使用 <code>Object.defineProperty</code> 和 Vue3 中使用 <code>Proxy</code> 实现了双向绑定。那么它是如何具体实现的？以下，我们便探讨如何自己手写一个双向绑定。</p></blockquote><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>首先我们的 HTML 中渲染一个 <code>&lt;p&gt;</code>标签 和一个 <code>&lt;input&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title-1&quot;</span>&gt;</span>Vue Demo: Object.defineProperty()<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果我们通过 <code>Object.defineProperty</code> 来实现双向绑定，我们需要重写 <code>data</code> 中的 <code>get</code> 和 <code>set</code> 方法。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 此处我们将 data.content 的值绑定至 p 和 input 上。</span><br><span class="hljs-keyword">let</span> data = &#123;<br>    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> el = &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.title-1&#x27;</span>),<br>    <span class="hljs-attr">input</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.input-1&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 在 Vue2 中实际是对 data 进行了一个 Object.keys() 遍历后再重写的方法。这里我们简写即可。</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data,<span class="hljs-string">&#x27;content&#x27;</span>,&#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> el.<span class="hljs-property">title</span>.<span class="hljs-property">innerHTML</span><br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">val</span>)&#123;<br>        el.<span class="hljs-property">input</span>.<span class="hljs-property">value</span> = val<br>        el.<span class="hljs-property">title</span>.<span class="hljs-property">innerHTML</span> = val<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>但这还不够，既然是双向绑定，那当我们输入值的时候，输入框里面的值更改也会影响到 <code>data.content</code> 的值，所以我们还得对 <code>input</code> 加入一个 <code>keyup</code>或者 <code>input</code> 的监听事件。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">el.<span class="hljs-property">input</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>    data.<span class="hljs-property">content</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>&#125;)<br><span class="hljs-comment">// 此外，在 Vue 中的 v-model 实际是一个语法糖，实现了 :value=&quot;myVal&quot; 和 @input=&quot;myVal=$event.target.value&quot;</span><br></code></pre></td></tr></table></figure><p><strong>在线示例</strong></p><p><a href="https://codepen.io/kingcheni/pen/jOzVPyr">CodePen.io</a></p><p>具体效果如下：</p><div>    <p class="title-1" style="display:block;height:20px">Vue Demo: Object.defineProperty()</p>    <input class="input-1" /></div> <h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>然后我们使用 <code>Proxy</code> 来实现这个双向绑定。同理，我们在页面渲染一个 <code>&lt;p&gt;</code> 标签和一个 <code>&lt;input&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title-2&quot;</span>&gt;</span>Vue Demo: Proxy<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;input-2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = &#123;<br>    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> el = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.title-2&#x27;</span>),<br>  <span class="hljs-attr">input</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.input-2&#x27;</span>)<br>&#125;<br><br>data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data,&#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target,property,receiver</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target,property,receiver)<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target,property,value,receiver</span>)&#123;<br>        el.<span class="hljs-property">input</span>.<span class="hljs-property">value</span> = value<br>        el.<span class="hljs-property">title</span>.<span class="hljs-property">innerHTML</span> = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>)<br>    &#125;<br>&#125;)<br><br>el.<span class="hljs-property">input</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;<br>  data.<span class="hljs-property">content</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>在线示例</strong></p><p><a href="https://codepen.io/kingcheni/pen/ExENjmQ">CodePen.io</a></p><p>具体效果如下：</p><div id="app">  <p class="title-2" style="display:block;height:20px">Vue Demo: Proxy</p>  <input class="input-2" /></div><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>以上只是开胃菜，现在我们还实现一个稍微完整点的Demo。包含 <code>v-bind</code> <code>v-model</code> <code>@click</code> 等。</p><p>HTML代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;count&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;count&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;reduce&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span>Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js代码如下：</p><p><strong>Vue类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>)&#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span><br>    vm.<span class="hljs-property">$el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(options.<span class="hljs-property">el</span>)<br>    vm.<span class="hljs-property">$methods</span> = options.<span class="hljs-property">methods</span><br>    <span class="hljs-keyword">let</span> data = options.<span class="hljs-property">data</span><br>    data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&quot;function&quot;</span> ? data.<span class="hljs-title function_">call</span>(vm,vm) : data || &#123;&#125;<br>    vm.<span class="hljs-property">_binding</span> = &#123;&#125;<br>    vm.<span class="hljs-title function_">_observer</span>(data)<br>    vm.<span class="hljs-title function_">_compile</span>(vm.<span class="hljs-property">$el</span>)<br>  &#125;<br>  <span class="hljs-title function_">_pushWatcher</span>(<span class="hljs-params">watcher</span>)&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">_binding</span>[watcher.<span class="hljs-property">key</span>])&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_binding</span>[watcher.<span class="hljs-property">key</span>] = []<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_binding</span>[watcher.<span class="hljs-property">key</span>].<span class="hljs-title function_">push</span>(watcher)<br>  &#125;<br>  <span class="hljs-title function_">_observer</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">const</span> handler = &#123;<br>      <span class="hljs-title function_">set</span>(<span class="hljs-params">target,property,value</span>)&#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>)<br>        vm.<span class="hljs-property">_binding</span>[property].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          <span class="hljs-comment">// 调用指定方法，更新视图</span><br>          item.<span class="hljs-title function_">update</span>()<br>        &#125;)<br>        <span class="hljs-keyword">return</span> res<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 利用 Proxy 实现的双向绑定</span><br>    vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data,handler)<br>  &#125;<br>  <span class="hljs-title function_">_compile</span>(<span class="hljs-params">root</span>)&#123;<br>    <span class="hljs-keyword">const</span> nodes = [...root.<span class="hljs-property">children</span>]<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_data</span><br>    nodes.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// 遍历根元素节点下的子元素</span><br>      <span class="hljs-keyword">if</span>(node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-comment">// 如果子元素下仍然包含子元素，则递归遍历</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_compile</span>(node.<span class="hljs-property">children</span>)<br>      &#125;<br>      <span class="hljs-keyword">const</span> $input = node.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;input&#x27;</span><br>      <span class="hljs-keyword">const</span> $textarea = node.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;textarea&#x27;</span><br>      <span class="hljs-keyword">const</span> $vmodel = node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&#x27;v-model&#x27;</span>)<br>      <span class="hljs-keyword">if</span>($vmodel &amp;&amp; ($input || $textarea))&#123;<br>        <span class="hljs-comment">// 此处判断该 input 或 textarea 元素是否含有 v-model 双向绑定相关的属性。如果有则添加 Watcher 和事件监听</span><br>         <span class="hljs-keyword">const</span> key = node.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;v-model&#x27;</span>)<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_pushWatcher</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(node,<span class="hljs-string">&#x27;value&#x27;</span>,data,key))<br>         node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>,<span class="hljs-function">() =&gt;</span>&#123;<br>            data[key] = node.<span class="hljs-property">value</span><br>         &#125;)<br>      &#125;<br>      <span class="hljs-keyword">if</span>(node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&#x27;v-bind&#x27;</span>))&#123;<br>        <span class="hljs-comment">// 此处判断指定节点是否存在 v-bind。若存在则添加 Watcher</span><br>         <span class="hljs-keyword">const</span> key = node.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;v-bind&#x27;</span>)<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_pushWatcher</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(node,<span class="hljs-string">&#x27;innerHTML&#x27;</span>,data,key))<br>      &#125;<br>      <span class="hljs-keyword">if</span>(node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&#x27;@click&#x27;</span>))&#123;<br>        <span class="hljs-comment">// 此处判断指定节点是否存在 @click。若存在则添加相关事件绑定。</span><br>        <span class="hljs-keyword">const</span> name = node.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;@click&#x27;</span>)<br>        <span class="hljs-keyword">const</span> method = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$methods</span>[name].<span class="hljs-title function_">bind</span>(data)<br>        node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,method)<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Watcher类</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span>&#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">node,attr,data,key</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span> = node<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">attr</span> = attr<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">update</span>() <span class="hljs-comment">// 将视图初始化</span><br>  &#125;<br>  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 此处实际上就是更新视图的。操作类似于 el.value = newVal / el.innerHTML = newVal</span><br>    <span class="hljs-keyword">let</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span>)<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">node</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">attr</span>,value)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Vue实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = <span class="hljs-number">99</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 为什么 data 是一个函数而不是一个对象。</span><br>    <span class="hljs-comment">// 因为 Vue 中可以会存在多个实例，如果它是一个对象，会导致所有的实例公用一个对象。从而会导致数据出现混乱的情况。</span><br>    <span class="hljs-comment">// 而使用函数，每次实例化一个Vue都会返回一个全新的data，不会导致数据出现混乱的情况。</span><br>    <span class="hljs-keyword">return</span>&#123;<br>      <span class="hljs-attr">count</span>: count<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;,<br>    <span class="hljs-title function_">reduce</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>--<br>    &#125;,<br>    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = count<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>在线示例</strong></p><p><a href="https://codepen.io/kingcheni/pen/abYmEWp">CodePen.io</a></p><p>具体效果如下：</p><div id="my-app">  <p v-bind="count" style="display:block;height:20px">Vue Demo</p>  <input type="text" v-model="count">  <button @click="add">+</button>  <button @click="reduce">-</button>  <button @click="reset">Reset</button></div><h2 id="THE-END"><a href="#THE-END" class="headerlink" title="THE END"></a>THE END</h2><p>综上便是一个 Vue 双向绑定的 Demo 实现。实际上 Vue 的源码层面还是稍微有点复杂的，在整个实例创建过程中还涉及到虚拟DOM、生命周期（Hook函数）等等操作。有兴趣可以直接前往 Vue 仓库查看具体代码实现。</p><script src="../../../../js/vue-demo.js"></script>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitalk：一款根据Github Issues开发的评论插件</title>
    <link href="/2022/07/11/7-share-gitalk/"/>
    <url>/2022/07/11/7-share-gitalk/</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p class="title title-success">Gitalk</p><p>Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。</p><p>我对其进行了二次开发，加入了图片上传的功能，可以 <a href="https://github.com/KingCheni/gitalk">点击此处</a> 查看该仓库。</p><p>也就是您浏览的这个网站正在使用的插件，可以将滚动条拖动至底部查看。</p>          </div><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>使用 GitHub 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru, de, pl, ko, fa, ja]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd|ctrl + enter）</li><li><strong>支持图片上传</strong> （注：我自己 fork 了原仓库，加入的功能。官方暂无，已提交PR。）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>加入了新功能的版本：</strong></p><p>访问该 <a href="https://github.com/KingCheni/gitalk">URL</a>，查看右侧发行的最新版本，下载 <code>gitalk.min.js</code> 和 <code>gitalk.css</code> 导入进您的项目中使用即可。</p><p>OR</p><p><strong>您也可以使用<a href="https://github.com/gitalk/gitalk">官方版本</a>：</strong></p><ul><li>直接引入</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- or --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>npm 安装</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm i --save gitalk<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;gitalk/dist/gitalk.css&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Gitalk</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;gitalk&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先，您需要选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论，</p><p>然后需要创建 <strong>GitHub Application</strong>，如果没有 <a href="https://github.com/settings/applications/new">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p><p>最后, 您可以选择如下的其中一种方式应用到页面：</p><h3 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h3><p>添加一个容器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gitalk-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用下面的 Javascript 代码来生成 gitalk 插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gitalk</span>(&#123;<br>  <span class="hljs-attr">clientID</span>: <span class="hljs-string">&#x27;GitHub Application Client ID&#x27;</span>,<br>  <span class="hljs-attr">clientSecret</span>: <span class="hljs-string">&#x27;GitHub Application Client Secret&#x27;</span>,<br>  <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;GitHub repo&#x27;</span>,<br>  <span class="hljs-attr">owner</span>: <span class="hljs-string">&#x27;GitHub repo owner&#x27;</span>,<br>  <span class="hljs-attr">admin</span>: [<span class="hljs-string">&#x27;GitHub repo owner and collaborators, only these guys can initialize github issues&#x27;</span>],<br>  <span class="hljs-attr">id</span>: location.<span class="hljs-property">pathname</span>,      <span class="hljs-comment">// Ensure uniqueness and length less than 50</span><br>  <span class="hljs-attr">distractionFreeMode</span>: <span class="hljs-literal">false</span>  <span class="hljs-comment">// Facebook-like distraction free mode</span><br>&#125;)<br><br>gitalk.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;gitalk-container&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="方式2：在React使用"><a href="#方式2：在React使用" class="headerlink" title="方式2：在React使用"></a>方式2：在React使用</h3><p>使用以下代码引入Gitalk组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">GitalkComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;gitalk/dist/gitalk-component&quot;</span>;<br></code></pre></td></tr></table></figure><p>按以下方式在React中使用Gitalk组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;<span class="hljs-title class_">GitalkComponent</span> options=&#123;&#123;<br>  <span class="hljs-attr">clientID</span>: <span class="hljs-string">&quot;...&quot;</span>,<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 设置项</span><br>&#125;&#125; /&gt;<br></code></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul><li><p><strong>clientID</strong> <code>String</code> </p><p><strong>必须</strong>. GitHub Application Client ID.</p></li><li><p><strong>clientSecret</strong> <code>String</code> </p><p><strong>必须</strong>. GitHub Application Client Secret.</p></li><li><p><strong>repo</strong> <code>String</code> </p><p><strong>必须</strong>. GitHub repository.</p></li><li><p><strong>owner</strong> <code>String</code> </p><p><strong>必须</strong>. GitHub repository 所有者，可以是个人或者组织。</p></li><li><p><strong>admin</strong> <code>Array</code> </p><p><strong>必须</strong>. GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)。</p></li><li><p><strong>id</strong> <code>String</code> </p><p>Default: <code>location.href</code>.</p><p>页面的唯一标识。长度必须小于50。</p></li><li><p><strong>number</strong> <code>Number</code> </p><p>Default: <code>-1</code>.</p><p>页面的 issue ID 标识，若未定义<code>number</code>属性则会使用<code>id</code>进行定位。</p></li><li><p><strong>labels</strong> <code>Array</code> </p><p>Default: <code>[&#39;Gitalk&#39;]</code>.</p><p>GitHub issue 的标签。</p></li><li><p><strong>title</strong> <code>String</code> </p><p>Default: <code>document.title</code>.</p><p>GitHub issue 的标题。</p></li><li><p><strong>body</strong> <code>String</code> </p><p>Default: <code>location.href + header.meta[description]</code>.</p><p>GitHub issue 的内容。</p></li><li><p><strong>language</strong> <code>String</code> </p><p>Default: <code>navigator.language || navigator.userLanguage</code>.</p><p>设置语言，支持 [en, zh-CN, zh-TW, es-ES, fr, ru, de, pl, ko, fa, ja]。</p></li><li><p><strong>perPage</strong> <code>Number</code> </p><p>Default: <code>10</code>.</p><p>每次加载的数据大小，最多 100。</p></li><li><p><strong>distractionFreeMode</strong> <code>Boolean</code> </p><p>Default: false。</p><p>类似Facebook评论框的全屏遮罩效果.</p></li><li><p><strong>pagerDirection</strong> <code>String</code></p><p>Default: ‘last’</p><p>评论排序方式， <code>last</code>为按评论创建时间倒叙，<code>first</code>为按创建时间正序。</p></li><li><p><strong>createIssueManually</strong> <code>Boolean</code> </p><p>Default: <code>false</code>.</p><p>如果当前页面没有相应的 isssue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 <code>true</code>，则显示一个初始化页面，创建 issue 需要点击 <code>init</code> 按钮。</p></li><li><p><strong>proxy</strong> <code>String</code> </p><p>Default: <code>https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token</code>.</p><p> GitHub oauth 请求到反向代理，为了支持 CORS。 <a href="https://github.com/isaacs/github/issues/330">为什么要这样?</a></p></li><li><p><strong>flipMoveOptions</strong> <code>Object</code> </p><p>Default:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">staggerDelayBy</span>: <span class="hljs-number">150</span>,<br>  <span class="hljs-attr">appearAnimation</span>: <span class="hljs-string">&#x27;accordionVertical&#x27;</span>,<br>  <span class="hljs-attr">enterAnimation</span>: <span class="hljs-string">&#x27;accordionVertical&#x27;</span>,<br>  <span class="hljs-attr">leaveAnimation</span>: <span class="hljs-string">&#x27;accordionVertical&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>评论列表的动画。 <a href="https://github.com/joshwcomeau/react-flip-move/blob/master/documentation/enter_leave_animations.md">参考</a></p></li><li><p><strong>enableHotKey</strong> <code>Boolean</code> </p><p>Default: <code>true</code>.</p><p>启用快捷键(cmd|ctrl + enter) 提交评论.</p></li></ul><div class="note note-warning">            <p><strong>注：</strong> 官方版本暂无 <code>upload</code> 参数</p>          </div><ul><li><p><strong>upload</strong> <code>Object</code> </p><p>Default:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">enable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 默认关闭上传功能</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 上传的URL</span><br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-comment">// 请求方式</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-comment">// 上传表单对应的名称</span><br>  <span class="hljs-attr">headers</span>: &#123; <span class="hljs-comment">// 请求头</span><br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;multipart/form-data&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">responseType</span>: <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-comment">// 响应格式</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">10000</span>, <span class="hljs-comment">// 超时时间，单位毫秒</span><br>  <span class="hljs-attr">multiple</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 文件上传是否可以多选</span><br>  <span class="hljs-attr">accept</span>: <span class="hljs-string">&#x27;image/*&#x27;</span>, <span class="hljs-comment">// 可接受文件的类型</span><br>  <span class="hljs-attr">fileMaxSize</span>: <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>, <span class="hljs-comment">// 文件限制大小</span><br>  <span class="hljs-attr">successCode</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// 上传成功码</span><br>  <span class="hljs-attr">successCodeKey</span>: [<span class="hljs-string">&#x27;code&#x27;</span>], <span class="hljs-comment">// 上传成功对应的字段，数组表示取返回内容（res）=&gt; res.code</span><br>  <span class="hljs-attr">errorMsgKey</span>: [<span class="hljs-string">&#x27;msg&#x27;</span>], <span class="hljs-comment">// 上传失败对应的字段 （res）=&gt; res.msg</span><br>  <span class="hljs-attr">errorMsg</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 默认错误信息，不填写则展示“上传失败”</span><br>  <span class="hljs-attr">successUrlKey</span>: [<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;url&#x27;</span>], <span class="hljs-comment">//上传成功对应的图片URL。例如 res.data.url</span><br>  <span class="hljs-attr">proxy</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 代理地址（便于跨域），可填写 https://cors-anywhere.azm.workers.dev/ , 真实请求地址为 https://cors-anywhere.azm.workers.dev/APIURL （其中APIURL指的上面填写的url）</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li><p><strong>render(String&#x2F;HTMLElement)</strong></p><p>初始化渲染并挂载插件。</p></li></ul><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>已经包括了配置项和Gitalk类的类型定义，不包括React组件的类型定义。</p><h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p>MIT LICENSE</p>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Gitalk</tag>
      
      <tag>插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 ES6 中的 Proxy 用法</title>
    <link href="/2022/07/08/6-talk-about-es6-proxy/"/>
    <url>/2022/07/08/6-talk-about-es6-proxy/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p class="title title-warning">WARNING</p><p>此处 <code>Proxy</code> 指的是ES6中的语法，而非 <a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions/API/proxy">FireFox proxy</a> 与 <a href="https://developer.chrome.com/docs/extensions/reference/proxy/">Chrome proxy</a> WebExtensions。请注意，前者是标准语法，P大写；而后者是对应厂商的私有技术，p小写。</p>          </div><h2 id="Proxy-介绍"><a href="#Proxy-介绍" class="headerlink" title="Proxy 介绍"></a>Proxy 介绍</h2><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN</a> 中的描述：<code>Proxy</code> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。其实通俗来讲，<code>Proxy</code> 相当于在原生方法（例如 <code>get</code> 访问Object的中的属性或方法、<code>set</code> 修改Object中的属性或方法、<code>has</code> 拦截”in操作符判断属性或方法是否存在Object或其原型链上”等等）之上的一层捕获器，可以进行拦截、修改等多种操作。<br><code>Proxy</code> 常见用法有很多，包括 <a href="https://hackernoon.com/introducing-javascript-es6-proxies-1327419ab413">运算符重载</a>，<a href="https://en.wikipedia.org/wiki/Mock_object">对象模拟</a>，<a href="https://medium.com/dailyjs/how-to-use-javascript-proxies-for-fun-and-profit-365579d4a9f8">简洁而灵活的API创建</a>，<a href="https://github.com/sindresorhus/on-change">对象更改事件</a> 等等。<br>又比如在 <a href="https://cn.vuejs.org/">Vue2</a> 中是通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>、<code>getter</code> 来实现的双向绑定，而在 <a href="https://v3.cn.vuejs.org/">Vue3</a> 中使用的正是 <code>Proxy</code> 来实现的双向绑定。</p></blockquote><div class="note note-info">            <p><code>Proxy</code> 用于修改某些操作的默认行为，也可以理解为在目标对象之前架设一层拦截，外部所有的访问都必须先通过这层拦截，因此提供了一种机制，可以对外部的访问进行过滤和修改。这个词的原理为代理，在这里可以表示由它来“代理”某些操作，译为“代理器”。</p>          </div><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><code>handler</code> 包含捕捉器（trap）的占位符对象，可译为处理器对象。</li><li><code>traps</code> 提供属性访问的方法。这类似于操作系统中捕获器的概念。 </li><li><code>target</code> 被 <code>Proxy</code> 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>ES6 原生提供了 <code>Proxy</code> 构造函数，用来生成 <code>Proxy</code> 实例。</p></blockquote><ul><li><code>target</code> 要使用 Proxy 包装的 <strong>目标对象</strong> <code>Object</code>（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li><code>handler</code> 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理的行为。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p><strong>注意：</strong> <code>target</code> 必须是 <code>Object</code> 类型，而不能是其他类型。</p>          </div><p><code>Proxy</code> 对象的所有用法，都是上面的这种形式。不同的只是 <code>handler</code> 参数的写法。其中 <code>new Proxy</code> 用来生成 <code>Proxy</code> 实例，<code>target</code> 是表示所要拦截的对象(Object)，<code>handler</code> 是用来定制拦截行为的对象。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>下面是 <code>Proxy</code> 最简单的例子是，这是一个有捕捉器的代理，一个 <code>get</code> 捕捉器，总是返回 <code>42</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> target = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-keyword">let</span> handler = &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> <span class="hljs-number">42</span><br>&#125;<br><br>target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)<br><br>target.<span class="hljs-property">x</span> <span class="hljs-comment">// 42</span><br>target.<span class="hljs-property">y</span> <span class="hljs-comment">// 42</span><br>target.<span class="hljs-property">x</span> <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><p>结果是一个对象将为任何属性访问操作都返回“42”。 这包括 <code>target.x</code>，<code>target[&#39;x&#39;]</code>，<code>Reflect.get(target, &#39;x&#39;)</code> 等。</p><h3 id="handler-对象的方法"><a href="#handler-对象的方法" class="headerlink" title="handler 对象的方法"></a>handler 对象的方法</h3><p><code>handler</code> 对象是一个容纳一批特定属性的占位符对象。它包含有 <code>Proxy</code> 的各个捕获器（trap）。</p><p>所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p><ul><li><code>getPrototypeOf()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf">Object.getPrototypeOf</a> 方法的捕捉器。</li><li><code>setPrototypeOf()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object.setPrototypeOf</a> 方法的捕捉器。</li><li><code>isExtensible()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible</a> 方法的捕捉器。</li><li><code>preventExtensions()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions">Object.preventExtensions</a> 方法的捕捉器。</li><li><code>getOwnPropertyDescriptor()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a> 方法的捕捉器。</li><li><code>defineProperty()</code>： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 方法的捕捉器。</li><li><code>has()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in">in</a> 操作符的捕捉器。</li><li><code>get()</code> ：属性读取操作的捕捉器。</li><li><code>set()</code> ：属性设置操作的捕捉器。</li><li><code>deleteProperty()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete">delete</a> 操作符的捕捉器。</li><li><code>ownKeys()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">Object.getOwnPropertyNames</a> 方法和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols</a> 方法的捕捉器。</li><li><code>apply()</code> ：函数调用操作的捕捉器。</li><li><code>construct()</code> ：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new</a> 操作符的捕捉器。</li></ul><p>此外，一些不标准的捕捉器已经被<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#proxy">废弃并且移除</a>了。</p><h2 id="Proxy-例子"><a href="#Proxy-例子" class="headerlink" title="Proxy 例子"></a>Proxy 例子</h2><h3 id="默认值-x2F-“零值”"><a href="#默认值-x2F-“零值”" class="headerlink" title="默认值&#x2F;“零值”"></a>默认值&#x2F;“零值”</h3><blockquote><p>在 Go 语言中，有零值(nil)的概念，零值是特定于类型的隐式默认结构值。其思想是提供类型安全的默认基元值，或者用gopher的话说，给结构一个有用的零值。</p></blockquote><p>虽然不同的创建模式支持类似的功能，但 Javascript 无法用隐式初始值包装对象。Javascript 中未设置属性的默认值是 <code>undefined</code>。但 <code>Proxy</code> 可以改变这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">withZeroValue</span> = (<span class="hljs-params">target, zeroValue</span>) =&gt; <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> (prop <span class="hljs-keyword">in</span> obj) ? obj[prop] : zeroValue<br>    &#125;)<br></code></pre></td></tr></table></figure><p>函数 <code>withZeroValue</code> 用来包装目标对象。 如果设置了属性，则返回属性值。 否则，它返回一个默认的 “零值” 。</p><p>从技术上讲，这种方法也不是隐含的，但如果我们扩展 <code>withZeroValue</code>，以 <code>Boolean (false)</code>, <code>Number (0)</code>, <code>String (&quot;&quot;)</code>, <code>Object (&#123;&#125;)</code>，<code>Array ([])</code>等对应的零值，则可能是隐含的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> pos = &#123;<br>  <span class="hljs-attr">x</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attr">y</span>: <span class="hljs-number">19</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pos.<span class="hljs-property">x</span>, pos.<span class="hljs-property">y</span>, pos.<span class="hljs-property">z</span>) <span class="hljs-comment">// 4, 19, undefined</span><br><br>pos = <span class="hljs-title function_">withZeroValue</span>(pos, <span class="hljs-number">0</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pos.<span class="hljs-property">z</span>, pos.<span class="hljs-property">y</span>, pos.<span class="hljs-property">z</span>) <span class="hljs-comment">// 4, 19, 0</span><br></code></pre></td></tr></table></figure><p>此功能可能有用的一个地方是坐标系。 绘图库可以基于数据的形状自动支持2D和3D渲染。 不是创建两个单独的模型，而是始终将z默认为 0 而不是 <code>undefined</code>，这可能是有意义的。</p><h3 id="负索引数组"><a href="#负索引数组" class="headerlink" title="负索引数组"></a>负索引数组</h3><blockquote><p>在JS中获取数组中的最后一个元素方式通过写的很冗长且重复，也容易出错。 这就是为什么有一个TC39提案定义了一个便利属性 <code>Array.lastItem</code> 来获取和设置最后一个元素。</p></blockquote><p>其他语言，如 Python 和 Ruby，使用负组索引更容易访问最后面的元素。例如，可以简单地使用 <code>arr[-1]</code> 替代 <code>arr[arr.length-1]</code> 访问最后一个元素。</p><p>使用 <code>Proxy</code> 也可以在 Javascript 中使用负索引。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">negativeArray</span> = (<span class="hljs-params">els</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(els, &#123;<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">target, property, receiver</span>) =&gt;</span> <br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(<br>        target,<br>        ( +property &lt; <span class="hljs-number">0</span>) ? <span class="hljs-title class_">String</span>( target.<span class="hljs-property">length</span> + +property ) : property, <br>        receiver<br>    )<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>target</code> : 目标对象。</li><li><code>property</code> : 被获取的属性名。</li><li><code>receiver</code> : <code>Proxy</code> 或者继承 <code>Proxy</code> 的对象</li></ul><div class="note note-info">            <p><code>Reflect</code> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 <code>Proxy handlers</code> 的方法相同。<code>Reflect</code> 不是一个函数对象，因此它是不可构造的。<br>与大多数全局对象不同 <code>Reflect</code> 并非一个构造函数，所以<strong>不能</strong>通过 <code>new</code> 运算符对其进行调用，或者将 <code>Reflect</code> 对象作为一个函数来调用。<code>Reflect</code> 的所有属性和方法都是静态的（就像 <code>Math</code> 对象）。<br><a style="color: var(--post-link-color);" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">点击可查看MDN解释</a></p>          </div><p>一个重要的注意事项是包含 <code>get</code> 的捕捉器（trap）字符串化所有属性。 对于数组访问，我们需要将属性名称强制转换为 <code>Numbers</code>，这样就可以使用加运算符（隐式转换）简洁地完成。</p><p>现在 <code>arr[-1]</code> 访问最后一个元素，<code>arr[-2]</code> 访问倒数第二个元素，以此类推。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">negativeArray</span>([<span class="hljs-string">&#x27;🚀&#x27;</span>, <span class="hljs-string">&#x27;📚&#x27;</span>, <span class="hljs-string">&#x27;🌈&#x27;</span>]);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[-<span class="hljs-number">1</span>]) <span class="hljs-comment">// &#x27;🌈&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[-<span class="hljs-number">2</span>]) <span class="hljs-comment">// &#x27;📚&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><blockquote><p>众所周知 JS 没有私有属性。 <code>Symbol</code> 最初是为了启用私有属性而引入的，但后来使用像 <code>Object.getOwnPropertySymbols</code> 这样的反射方法进行了淡化，这使得它们可以被公开发现。长期以来的惯例是将私有属性命名为前下划线 <code>_</code> ，有效地标记它们“不要访问”。<code>Proxy</code> 提供了一种稍微更好的方法来屏蔽这些属性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">hide</span> = (<span class="hljs-params">target, prefix = <span class="hljs-string">&#x27;_&#x27;</span></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>  <span class="hljs-attr">has</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> (!prop.<span class="hljs-title function_">startsWith</span>(prefix) &amp;&amp; prop <span class="hljs-keyword">in</span> obj),<br>  <span class="hljs-attr">ownKeys</span>: <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)<br>    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> (<span class="hljs-keyword">typeof</span> prop !== <span class="hljs-string">&quot;string&quot;</span> || !prop.<span class="hljs-title function_">startsWith</span>(prefix))),<br>  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop, rec</span>) =&gt;</span> (prop <span class="hljs-keyword">in</span> rec) ? obj[prop] : <span class="hljs-literal">undefined</span><br>&#125;)<br></code></pre></td></tr></table></figure><p><code>hide</code> 函数包装目标对象，并使得从 <code>in</code> 运算符和 <code>Object.getOwnPropertyNames</code> 等方法无法访问带有下划线的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> userData = <span class="hljs-title function_">hide</span>(&#123;<br>  <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>  <span class="hljs-attr">mediumHandle</span>: <span class="hljs-string">&#x27;@tbarrasso&#x27;</span>,<br>  <span class="hljs-attr">_favoriteRapper</span>: <span class="hljs-string">&#x27;Drake&#x27;</span><br>&#125;)<br><br>userData.<span class="hljs-property">_favoriteRapper</span>        <span class="hljs-comment">// undefined</span><br>(<span class="hljs-string">&#x27;_favoriteRapper&#x27;</span> <span class="hljs-keyword">in</span> userData) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>更完整的实现还包括诸如 <code>deleteProperty</code> 和 <code>defineProperty</code> 之类的捕捉器。 除了闭包之外，这可能是最接近真正私有属性的方法，因为它们无法通过枚举，克隆，访问或修改来访问。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在客户端和服务器之间同步状态时遇到困难并不罕见。数据可能会随着时间的推移而发生变化，很难确切地知道何时重新同步的逻辑。</p><p><code>Proxy</code> 启用了一种新方法：根据需要将对象包装为无效（和重新同步）属性。 所有访问属性的尝试都首先检查缓存策略，该策略决定返回当前在内存中的内容还是采取其他一些操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ephemeral</span> = (<span class="hljs-params">target, ttl = <span class="hljs-number">60</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CREATED_AT</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isExpired</span> = (<span class="hljs-params"></span>) =&gt; (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-variable constant_">CREATED_AT</span>) &gt; (ttl * <span class="hljs-number">1000</span>)<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span> <span class="hljs-title function_">isExpired</span>() ? <span class="hljs-literal">undefined</span> : <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, prop)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数过于简化了: 它使对象上的所有属性在一段时间后都无法访问。然而，将此方法扩展为根据每个属性设置生存时间(TTL)，并在一定的持续时间或访问次数之后更新它并不困难。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bankAccount = <span class="hljs-title function_">ephemeral</span>(&#123;<br>  <span class="hljs-attr">balance</span>: <span class="hljs-number">14.93</span><br>&#125;, <span class="hljs-number">10</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bankAccount.<span class="hljs-property">balance</span>)    <span class="hljs-comment">// 14.93</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bankAccount.<span class="hljs-property">balance</span>)  <span class="hljs-comment">// undefined</span><br>&#125;, <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>这个示例简单地使银行帐户余额在10秒后无法访问。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>也许从语法上讲，最吸引人的 <code>Proxy</code> 用例是重载操作符的能力，比如使用 <code>handler.has</code> 的 <code>in</code> 操作符。</p><p><code>in</code> 操作符用于检查指定的属性是否位于指定的对象或其原型链中。但它也是语法上最优雅的重载操作符。这个例子定义了一个连续range函数来比较数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">range</span> = (<span class="hljs-params">min, max</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>), &#123;<br>  <span class="hljs-attr">has</span>: <span class="hljs-function">(<span class="hljs-params">_, prop</span>) =&gt;</span> (+prop &gt;= min &amp;&amp; +prop &lt;= max)<br>&#125;)<br></code></pre></td></tr></table></figure><p>与Python不同，Python使用生成器与有限的整数序列进行比较，这种方法支持十进制比较，可以扩展为支持其他数值范围。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> X = <span class="hljs-number">10.5</span><br><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, X, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>]<br><br><span class="hljs-keyword">if</span> (X <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)) &#123; <span class="hljs-comment">// true</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>nums.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment">// [1, 5]</span><br></code></pre></td></tr></table></figure><p>尽管这个用例不能解决复杂的问题，但它确实提供了干净、可读和可重用的代码。</p><p>除了 <code>in</code> 运算符，我们还可以重载 <code>delete</code> 和 <code>new</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>为什么要用 Proxy ?</strong></p><p>就拿 Vue 举例来说，在 Vue2 中当一个 Vue 实例创建时，Vue 会遍历 <code>data</code> 中的属性，用 <code>Object.defineProperty</code> 将它们转为 <code>getter/setter</code>，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 <code>watcher</code> 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 <code>setter</code> 被调用时，会通知 <code>watcher</code> 重新计算，从而致使它关联的组件得以更新。</p><p>而这样一个个遍历对 <code>data</code> 进行修改显然是不高效的，所以在 Vue3 中使用了 Proxy 来进行数据劫持。</p><p>Vue3 使用 Proxy 来监控数据的变化。就本文以上所说，Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于 <code>Object.defineProperty()</code>，其有以下特点：</p><ol><li><code>Proxy</code> 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li><code>Proxy</code> 可以监听数组的变化。(在 Vue2 中是重写了数组中的各种方法才达到监听的目的，如 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code>、<code>sort</code>、<code>reverse</code> 等)</li></ol><p>在 Vue2 中，<code>Object.defineProperty</code> 会改变原始数据，而 <code>Proxy</code> 是创建对象的虚拟表示，并提供 <code>set</code> 、<code>get</code> 和 <code>deleteProperty</code> 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p><ul><li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li><li>全方位的数组变化检测，消除了 Vue2 无效的边界情况。</li><li>支持 <code>Map</code>，<code>Set</code>，<code>WeakMap</code> 和 <code>WeakSet</code>。</li></ul><p>Vue3 中 <code>Proxy</code> 实现的响应式原理与 Vue2 的实现原理相同，实现方式大同小异∶ </p><ul><li><code>get</code> 收集依赖；</li><li><code>set</code>、<code>delete</code> 等触发依赖；</li><li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑；</li></ul><p><strong>THE END</strong></p><p><code>Proxy</code> 提供虚拟化接口来控制任何目标 <code>Object</code> 的行为。 这样做可以在简单性和实用性之间取得平衡，而不会牺牲兼容性。</p><p>也许使用 <code>Proxy</code> 的最令人信服的理由是，上面的许多示例只有几行，并且可以轻松组合以创建复杂的功能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://segmentfault.com/a/1190000019725835?utm_source=sf-similar-article">Proxy 的巧用 - 思否</a> 翻译自 <a href="https://blog.bitsrc.io/a-practical-guide-to-es6-proxy-229079c3c2f0">A practical guide to Javascript Proxy | by Thomas Barrasso | Bits and Pieces</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy - JavaScript | MDN</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>Proxy</tag>
      
      <tag>Object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网站如何防止被iframe引用</title>
    <link href="/2022/07/06/5-website-block-iframe/"/>
    <url>/2022/07/06/5-website-block-iframe/</url>
    
    <content type="html"><![CDATA[<h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p><code>X-Frame-Options</code> 通常存在三个值，被设置在服务端返回头（Response Header）中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">X-Frame-Options: DENY<br>X-Frame-Options: SAMEORIGIN<br>X-Frame-Options: ALLOW-FROM uri #此用法被弃用，可能不被支持<br></code></pre></td></tr></table></figure><p>如果设置为 <code>DENY</code>，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 <code>SAMEORIGIN</code>，那么页面就可以在同域名页面的 frame 中嵌套。</p><p><code>DENY</code></p><blockquote><p>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</p></blockquote><p><code>SAMEORIGIN</code></p><blockquote><p>表示该页面可以在相同域名页面的 frame 中展示。规范让浏览器厂商决定此选项是否应用于顶层、父级或整个链，有人认为该选项不是很有用，除非所有的祖先页面都属于同一来源（origin）。参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">浏览器兼容性</a>以获取详细的兼容性信息。</p></blockquote><p><code>ALLOW-FROM uri</code> <strong>已弃用</strong></p><blockquote><p>这是一个被弃用的指令，不再适用于现代浏览器，请不要使用它。在支持旧版浏览器时，页面可以在指定来源的 frame 中展示。请注意，在旧版 Firefox 上，它会遇到与 <code>SAMEORIGIN</code> 相同的问题——它不会检查 frame 所有的祖先页面来确定他们是否是同一来源。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy</a> HTTP 首部有一个 <code>frame-ancestors</code> 指令，你可以使用这一指令来代替。</p></blockquote><div class="note note-danger">            <p><strong>备注：</strong> 使用 <code>&lt;meta&gt;</code> 标签来设置 <code>X-Frame-Options</code> 是无效的！例如 <code>&lt;meta http-equiv=&quot;X-Frame-Options&quot; content=&quot;deny&quot;&gt;</code> 没有任何效果。不要这样用！只有当像下面示例那样设置 HTTP 头 <code>X-Frame-Options </code>才会生效。</p>          </div><h2 id="CSP-frame-ancestors"><a href="#CSP-frame-ancestors" class="headerlink" title="CSP: frame-ancestors"></a>CSP: frame-ancestors</h2><p>HTTP 头部 <code>Content-Security-Policy</code> (CSP) 指令指定了一个可以包含<code>&lt;frame&gt;</code>，<code>&lt;iframe&gt;</code>，<code>&lt;object&gt;</code>，<code>&lt;embed&gt;</code>，or <code>&lt;applet&gt;</code>等元素的有效父级。</p><p>当 <code>frame-ancestors</code> 被设置成 <code>none</code> 时，类似于 <code>X-Frame-Options: DENY</code> 。</p><div class="note note-warning">            <p>该指令不支持通过 <code>&lt;meta&gt;</code> 元素或通过 <code>Content-Security-policy-Report-Only</code> 头域所指定。</p>          </div><p><code>frame-ancestors</code> 策略可以设置一个或多个源 <code>&lt;source&gt;</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">Content-Security-Policy: frame-ancestors &lt;source&gt;;<br>Content-Security-Policy: frame-ancestors &lt;source&gt; &lt;source&gt;;<br></code></pre></td></tr></table></figure><source> 可以是如下内容：<p><code>&lt;host-source&gt;</code></p><blockquote><p>一个 Internet 主机的名称或 IP 地址，以及一个可选的URL scheme和／或端口号。这些站点的地址可以包含一个可选的引导通配符（星号， ‘*‘），或者你可以使用通配符（同样还是， ‘*‘）作为端口地址，以示这个源的所有合法端口地址都是有效的。<br>例子：</p></blockquote><ul><li>http:&#x2F;&#x2F;*.example.com: 匹配所有使用 http:URL scheme 并来对于 example.com 及其子域名的加载意图。</li><li>mail.example.com:443: 匹配所有对于 mail.example.com 在 443 端口的访问意图。</li><li><a href="https://store.example.com/">https://store.example.com</a>: 匹配所有使用 https:访问 store.example.com 的意图。</li></ul><p><code>&lt;scheme-source&gt;</code></p><blockquote><p>一个 schema 配置，比如’http:’或’https:’。注意，冒号是必要的。你同样也可以指定一个 data schema（但并不推荐）。</p></blockquote><ul><li><code>&#39;data:&#39;</code> 允许 data: URIs 作为内容源。 这是不安全的，攻击者可以用此来注入恶意代码。请谨慎使用，并不要令其作用于脚本。</li><li><code>&#39;mediastream:&#39;</code> 允许 mediastream: URIs 作为内容源。</li><li><code>&#39;blob:&#39;</code> 允许 blob: URIs 作为内容源。</li><li><code>&#39;filesystem:&#39;</code> 允许 filesystem: URIs 作为内容源。</li></ul><p><code>&#39;self&#39;</code></p><blockquote><p>指向一个该受保护文档所在的源，包含同样的 URL schema 和端口号。必须用单引号设置。有些浏览器会从源指令中排除 blob和filesystem。需要允许这些内容类型的站点可以通过 Data 属性指定它们。</p></blockquote><p><code>&#39;none&#39;</code></p><blockquote><p>指向一个空集，意味着没有 URL 会被匹配。也需要单引号包裹设置。</p></blockquote><div class="note note-success">            <p>一般来说，建议将 <code>X-Frame-Options: &lt;value&gt;</code> 与 <code>Content-Security-Policy: frame-ancestors &lt;source&gt;</code> 联合使用。因为 <code>X-Frame-Options</code> 是一种非标准的写法（当然，浏览器也支持这种写法）。但是相对CSP标准而言，在IE浏览器下不支持 <code>frame-ancestors</code>，仅支持 <code>X-Frame-Options</code>。相对于Chrome与FireFox来讲，若两者均存在，会优先读取 <code>frame-ancestors</code>的值。所以将二者同时使用是一个更好的操作。</p>          </div><h2 id="JS代码判断"><a href="#JS代码判断" class="headerlink" title="JS代码判断"></a>JS代码判断</h2><div class="note note-warning">            <p>当然，JS代码也可以判断当前页面是否被另一页面进行iframe嵌套。但是通常情况下，并不赞成通过JS代码来进行判断。</p>          </div><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">top</span> !== <span class="hljs-variable language_">window</span>.<span class="hljs-property">self</span>)&#123;<br>    <span class="hljs-comment">// todo next</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options - HTTP | MDN</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors">CSP: frame-ancestors - HTTP | MDN</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>WEB安全</tag>
      
      <tag>CSP</tag>
      
      <tag>X-Frame-Options</tag>
      
      <tag>frame-ancestors</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node与浏览器中EventLoop有什么区别</title>
    <link href="/2022/07/04/4-js-event-loop/"/>
    <url>/2022/07/04/4-js-event-loop/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器中的EventLoop"><a href="#浏览器中的EventLoop" class="headerlink" title="浏览器中的EventLoop"></a>浏览器中的EventLoop</h2><blockquote><p>众所周知， <code>JS</code> 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行 <code>同步代码</code> 时，如果遇到 <code>异步事件</code>，<code>JS</code> 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当 <code>异步事件</code> 执行完毕后，再将 <code>异步事件</code> 对应的回调加入到一个任务队列中等待执行。该异步任务队列可以分为 <code>宏任务队列</code> 和 <code>微任务队列</code> ，当当前执行栈中的事件执行完毕后，<code>JS</code> 引擎首先会判断<code>微任务队列</code>中是否有任务可以执行，如果有就将<code>微任务队首</code>的事件压入栈中执行。当<code>微任务队列</code>中的任务都执行完成后再去执行<code>宏任务队列</code>中的任务。</p></blockquote><p><img src="https://image.origin-tec.com/img/62fb0ea6cfeaef749c59f6626a69f9c5@1053x424.png" alt="EventLoop"></p><p><strong>Event Loop 执行顺序如下所示：</strong></p><ul><li>整体script代码进入执行栈执行，依次执行所有同步代码。</li><li>然后开始执行异步代码，将遇到的异步代码分为<strong>宏任务</strong>(macro-task)、<strong>微任务</strong>(micro-stak)，各自产生的回调分别放入各自的队列（宏任务队列微任务队列是不同的队列）。</li><li>此时等待主线执行栈执行同步代码结束后，开始依次执行微任务队列中代码直到微任务队列为空，再执行宏任务队列中下一个宏任务，依次循环。</li></ul><p class="note note-warning">注意：宏任务、微任务中又可能包括宏、微任务，仍然按照以上规则处理，顺序不能乱。</p><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><table><thead><tr><th>#</th><th align="center">浏览器</th><th align="center">Node</th></tr></thead><tbody><tr><td>I&#x2F;O</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>setTimeout</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>setInterval</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td>setImmediate</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td>requestAnimationFrame</td><td align="center">✅</td><td align="center">❌</td></tr></tbody></table><h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><table><thead><tr><th>#</th><th align="center">浏览器</th><th align="center">Node</th></tr></thead><tbody><tr><td>process.nextTick</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td>MutationObserver</td><td align="center">✅</td><td align="center">❌</td></tr><tr><td>Promise.then catch finally</td><td align="center">✅</td><td align="center">✅</td></tr></tbody></table><h3 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>当我们在函数前使用 <code>async</code> 的时候，使得该函数返回的是一个 <code>Promise</code> 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>   <span class="hljs-comment">// async的函数会在这里帮我们隐式使用Promise.resolve(1)</span><br>&#125;<br><span class="hljs-comment">// 等价于下面的代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>   &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>可见 <code>async</code> 只是一个语法糖，只是帮助我们返回一个 <code>Promise</code> 而已</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><code>await</code> 表示等待，是右侧「表达式」的结果，这个表达式的计算结果可以是 <code>Promise</code> 对象的值或者一个函数的值（换句话说，就是没有特殊限定）。并且只能在带有 <code>async</code> 的内部使用</p><p>使用 <code>await</code> 时，会从右往左执行，当遇到 <code>await</code> 时，会阻塞函数内部处于它后面的代码，去执行该函数外部的同步代码，当外部同步代码执行完毕，再回到该函数内部执行剩余的代码, 并且当 <code>await</code> 执行完毕之后，<strong>会先处理微任务队列的代码</strong>。</p><p>下面来看一个栗子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>)<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span> )<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"> resolve </span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>();<br>&#125; ).<span class="hljs-title function_">then</span>( <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125; )<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>使用事件循环机制分析:</strong></p><ul><li>首先执行同步代码，执行<code>console.log(&#39;script start&#39;)</code></li><li>遇到 <code>setTimeout</code> ，会被推入宏任务队列</li><li>执行 <code>async1()</code>， 它也是同步的，只是返回值是<code>Promise</code>，在内部首先执行<code>console.log(&#39;async1 start&#39;)</code></li><li>然后执行<code>async2()</code>， 然后会打印 <code>console.log(&#39;async2&#39;)</code></li><li>从右到左会执行， 当遇到<code>await</code>的时候，阻塞后面的代码，会将<code>console.log(&#39;async1 end&#39;)</code>放入微任务队列中，然后去外部执行同步代码</li><li>进入 <code>new Promise</code>，打印 <code>console.log(&#39;promise1&#39;)</code></li><li>将<code>.then</code>放入事件循环的微任务队列</li><li>继续执行，打印<code>console.log(&#39;script end&#39;)</code></li><li>外部同步代码执行完毕，接着回到<code>async1()</code>内部， 由于<code>async2()</code>其实是返回一个<code>Promise</code>， <code>await - async2()</code>相当于获取它的值，其实就相当于这段代码<code>Promise.resolve(undefined).then((undefined) =&gt; &#123;&#125;)</code>，所以<code>.then</code>会被推入微任务队列。接下来处理微任务队列，依次打印<code>async1 end</code>和<code>promise2</code>，后面一个<code>.then</code>不会有任何打印，但是会执行</li><li>进入第二次事件循环，执行宏任务队列， 打印<code>console.log(&#39;setTimeout&#39;)</code></li></ul><p>浏览器中的执行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">script start<br>async1 start<br>async2<br>promise1<br>script end<br>async1 end<br>promise2<br>undefined<br>setTimeout<br></code></pre></td></tr></table></figure><h2 id="Node-中的-EventLoop"><a href="#Node-中的-EventLoop" class="headerlink" title="Node 中的 EventLoop"></a>Node 中的 EventLoop</h2><blockquote><p><code>Node</code> 中的 EventLoop 和浏览器中的是完全不相同的东西。<br><code>Node</code> 的 EventLoop 分为 <strong>6</strong> 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p></blockquote><ol><li><strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 <code>setTimeout</code> 和 <code>setInterval</code> ），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</li><li><strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I &#x2F; O回调（系统调用相关的回调）。</li><li><strong>Idle&#x2F;Prepare</strong>：仅供内部使用。</li><li><strong>Poll（轮询阶段）</strong>：<ul><li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li><li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（ <code>setTimeout</code> 、 <code>setInterval</code> 和 <code>setImmediate</code> ）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I&#x2F;O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li></ul></li><li><strong>Check（查询阶段）</strong>：会检查是否存在 <code>setImmediate</code> 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</li><li><strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</li></ol><h3 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a>setTimeout 和 setImmediate</h3><p>二者非常相似，区别主要在于调用时机不同。</p><ul><li><code>setImmediate</code> 设计在 poll 阶段完成时执行，即 check 阶段；</li><li><code>setTimeout</code> 设计在 poll 阶段为空闲时，且设定时间到达后执行，但它在 timer 阶段执行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p><ul><li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li><li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li></ul><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>    &#125;, <span class="hljs-number">0</span>)<br>    <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>setImmediate</code> 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p><p>上面都是 宏任务 的执行情况，对于 微任务 来说，它会在以上每个阶段完成前 <strong>清空</strong> 微任务 队列，下图中的 Tick 就代表了 微任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于以上代码来说，其实和浏览器中的输出是一样的，微任务microtask 永远执行在 宏任务macrotask 前面。</p><h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h3><p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 EventLoop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 微任务microtask 执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br> &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br> process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>   process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>     process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>     &#125;)<br>   &#125;)<br> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.yuque.com/cuggz/interview/browser">前端面试题之浏览器原理篇 - 语雀</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.wangt.cc/2021/09/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E3%80%81%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/">事件循环、同步异步、宏任务微任务 - 程序员灯塔</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://segmentfault.com/a/1190000017554062">js事件循环机制（浏览器端Event Loop) 以及async&#x2F;await的理解 - 思否</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Node</tag>
      
      <tag>浏览器</tag>
      
      <tag>EventLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染页面的原理</title>
    <link href="/2022/07/04/3-how-browser-render/"/>
    <url>/2022/07/04/3-how-browser-render/</url>
    
    <content type="html"><![CDATA[<h2 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h2><p>浏览器渲染主要有以下步骤：</p><ul><li>首先解析收到的文档，根据文档定义构建一棵 <code>DOM</code> (Document Object Model) 树，<code>DOM</code> 树是由 <code>DOM</code> 元素及属性节点组成的。</li><li>然后对 <code>CSS</code> 进行解析，生成 <code>CSSOM</code> (CSS Object Model) 规则树。</li><li>根据 <code>DOM</code> 树和 <code>CSSOM</code> 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 <code>DOM</code> 元素相对应，但这种对应关系不是一对一的，不可见的 <code>DOM</code> 元素不会被插入渲染树。还有一些 <code>DOM</code> 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做 <code>回流</code> ）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”（又称作 <code>重绘</code> ）。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ul><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><blockquote><p>当渲染树中部分或者全部元素的<strong>尺寸</strong>、<strong>结构</strong>或者<strong>属性</strong>发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p></blockquote><p>下面这些操作会导致回流：</p><ul><li>页面的首次渲染</li><li>浏览器的窗口大小发生变化</li><li>元素的内容发生变化</li><li>元素的尺寸或者位置发生变化</li><li>元素的字体大小发生变化</li><li>激活 <code>CSS</code> 伪类</li><li>查询某些属性或者调用某些方法</li><li>添加或者删除可见的 <code>DOM</code> 元素</li></ul><p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的 <code>DOM</code> 元素重新排列，它的影响范围有两种：</p><ul><li>全局范围：从根节点开始，对整个渲染树进行重新布局</li><li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><blockquote><p>当页面中某些元素的<strong>样式发生变化</strong>，但是<strong>不会影响</strong>其在<strong>文档流</strong>中的<strong>位置</strong>时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p></blockquote><p>下面这些操作会导致重绘：</p><ul><li><code>color</code> 、<code>background</code> 相关属性：<code>background-color</code>、<code>background-image</code> 等</li><li><code>outline</code> 相关属性：<code>outline-color</code>、<code>outline-width</code> 、<code>text-decoration</code></li><li><code>border-radius</code>、<code>visibility</code>、<code>box-shadow</code></li></ul><p class="note note-warning">注意： 当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</p><p><strong>浏览器的渲染大致过程如图所示：</strong></p><p><img src="https://image.origin-tec.com/img/153b18d744b58e6556e10af9b3f5a61e@663x307.png" alt="浏览器渲染过程图"></p><p class="note note-warning">注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 <b>html</b> 都解析完成之后再去构建和布局 <b>render</b> 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><h2 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h2><h3 id="针对JavaScript："><a href="#针对JavaScript：" class="headerlink" title="针对JavaScript："></a>针对JavaScript：</h3><blockquote><p><code>JavaScript</code> 既会阻塞 <code>HTML</code> 的解析，也会阻塞 <code>CSS</code> 的解析。因此我们可以对 <code>JavaScript</code> 的加载方式进行改变，来进行优化：</p></blockquote><p>（1）尽量将 JavaScript 文件放在 <code>body</code> 的最后</p><p>（2） <code>body</code> 中间尽量不要写 <code>&lt;script&gt;</code> 标签</p><p>（3）<code>&lt;script&gt;</code> 标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 <code>async</code> 属性和 <code>defer</code> 属性来异步引入，两者都是去异步加载外部的 JS 文件，不会阻塞 <code>DOM</code> 的解析（尽量使用异步加载）。三者的区别如下：</p><ul><li><code>script</code> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行 js 代码，js 代码执行完毕后继续渲染页面；</li><li><code>async</code> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带 <code>async</code> 属性的标签，不能保证加载的顺序；</li><li><code>defer</code> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果 DOM 树已经准备好，则立即执行。多个带 <code>defer</code> 属性的标签，按照顺序执行。</li></ul><h3 id="针对CSS："><a href="#针对CSS：" class="headerlink" title="针对CSS："></a>针对CSS：</h3><blockquote><p>使用 <code>CSS</code> 有三种方式：使用 <code>link</code> 、<code>@import</code>、<code>内联样式</code>，其中 <code>link</code> 和 <code>@import</code> 都是导入外部样式。它们之间的区别：</p></blockquote><ul><li><code>link</code> ：浏览器会派发一个新的线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li><li><code>@import</code> ：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li><li><code>style</code> ：GUI直接渲染</li></ul><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以 <code>CSS</code> 一般写在 <code>header</code> 中，让浏览器尽快发送请求去获取 <code>css</code> 样式。</p><p>所以，在开发过程中，导入外部样式使用 <code>link</code> ，而不用 <code>@import</code> 。如果 <code>css</code> 少，尽可能采用内嵌样式，直接写在 <code>style</code> 标签中。</p><h3 id="针对DOM树、CSSOM树："><a href="#针对DOM树、CSSOM树：" class="headerlink" title="针对DOM树、CSSOM树："></a>针对DOM树、CSSOM树：</h3><p>可以通过以下几种方式来减少渲染的时间：</p><ul><li>HTML文件的代码层级尽量不要太深</li><li>使用语义化的标签，来避免不标准语义化的特殊处理</li><li>减少CSS的代码的层级，因为选择器是<strong>从右往左</strong>进行解析的（<a href="https://segmentfault.com/q/1010000000713509">问题：为什么 CSS 选择器解析的时候是从右往左？</a>）</li></ul><h3 id="减少回流与重绘："><a href="#减少回流与重绘：" class="headerlink" title="减少回流与重绘："></a>减少回流与重绘：</h3><ul><li>操作 DOM 时，尽量在低层级的 DOM 节点进行操作</li><li>不要使用 <code>table</code> 布局，一个小的改动可能会使整个 <code>table</code> 进行重新布局</li><li>不使用CSS的表达式</li><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>使用 <code>absolute</code> 或者 <code>fixed</code> ，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li><li>避免频繁操作DOM，可以创建一个文档片段 <code>documentFragment</code> ，在它上面应用所有DOM操作，最后再把它添加到文档中</li><li>将元素先设置 <code>display: none</code>，操作结束后再把它显示出来。因为在 <code>display</code> 属性为 <code>none</code> 的元素上进行的 <code>DOM</code> 操作不会引发回流和重绘。</li><li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</li></ul><p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p><p>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p><p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p><h2 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h2><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 <code>DOM</code> 时， <code>HTML</code> 解析器若遇到了 <code>JavaScript</code> ，那么它会暂停文档的解析，将控制权移交给 <code>JavaScript</code> 引擎，等 <code>JavaScript</code> 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。当然在当下，并不是说 <code>script</code> 标签必须放在底部，因为你可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</p><h2 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h2><p><strong>Webkit</strong> 和 <strong>Firefox</strong> 都做了这个优化，当执行 <code>JavaScript</code> 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 <code>DOM</code> 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><h2 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h2><p>理论上，既然样式表不改变 <code>DOM</code> 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题， <code>JavaScript</code> 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 <code>CSSOM</code> 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 <code>JavaScript</code> 脚本执行和文档的解析，直至其完成 <code>CSSOM</code> 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 <code>CSSOM</code> ，然后再执行 <code>JavaScript</code> ，最后再继续文档的解析。</p><h2 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h2><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p><p> （1）关键资源的数量。</p><p> （2）关键路径长度。</p><p> （3）关键字节的数量。</p><blockquote><p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p></blockquote><p>优化关键渲染路径的常规步骤如下：</p><p> （1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p><p> （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p><p> （3）优化关键字节数以缩短下载时间（往返次数）。</p><p> （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p><h2 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h2><p>首先渲染的前提是生成渲染树，所以 <code>HTML</code> 和 <code>CSS</code> 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 <code>script</code> 标签时，会暂停构建 <code>DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载</code> JS 文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</p><p>当然在当下，并不是说 <code>script</code> 标签必须放在底部，因为你可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 JS 文件会并行下载，但是会放到 <code>HTML</code> 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code> 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 <code>async</code> 属性，表示 JS 文件下载和解析不会阻塞渲染。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.yuque.com/cuggz/interview/browser">前端面试题之浏览器原理篇 - 语雀</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>前端技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>浏览器</tag>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git连接Github失败解决办法</title>
    <link href="/2022/07/03/2-git-connect-github-with-errors/"/>
    <url>/2022/07/03/2-git-connect-github-with-errors/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">出现这些错误大多情况下是由当前使用了代理产生的，如果关闭了代理无法直连Github可以参考以下解决方案。</p><h2 id="HTTP-x2F-2-stream"><a href="#HTTP-x2F-2-stream" class="headerlink" title="HTTP&#x2F;2 stream"></a>HTTP&#x2F;2 stream</h2><p class="note note-danger">HTTP/2 stream 1 was not closed cleanly before end of the underlying stream</p><ul><li>提示默认通信协议出错，更改默认通信协议</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.version HTTP/1.1<br></code></pre></td></tr></table></figure><h2 id="OpenSSL-SSL-read"><a href="#OpenSSL-SSL-read" class="headerlink" title="OpenSSL SSL_read"></a>OpenSSL SSL_read</h2><p class="note note-danger">OpenSSL SSL_read: Connection was aborted, errno 10053</p><ul><li>可以尝试关闭SSL验证，在控制台输入如下命令即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.sslVerify <span class="hljs-string">&quot;false&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Failed-to-connect"><a href="#Failed-to-connect" class="headerlink" title="Failed to connect"></a>Failed to connect</h2><p class="note note-danger">Failed to connect to github.com port 443 after 21224 ms: Timed out </p><p>此情况网页可以正常打开Github，但是无法通过Git连接Github。而在电脑上运行了代理程序或使用了其他代理手段导致的。</p><h3 id="方法一：配置-http-代理"><a href="#方法一：配置-http-代理" class="headerlink" title="方法一：配置 http 代理"></a>方法一：配置 http 代理</h3><blockquote><p>Windows 中 git 默认不会使用系统代理，所以即使连接代理或者打开代理软件，浏览器仍然可以访问 GitHub 或 Gitee；但是使用 git 命令行连接 GitHub 或 Gitee 远程仓库可能会出现无法访问的现象。通过为 git 配置代理解决出现的问题。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 以下 host:port 指定是你当前代理使用的主机及端口号。例如：localhost:7890、127.0.0.1:7890 等</span><br><br><span class="hljs-comment"># 配置socks5代理</span><br>git config --global http.proxy socks5 host:port<br>git config --global https.proxy socks5 host:port<br><br><span class="hljs-comment"># 配置http代理</span><br>git config --global http.proxy host:port<br>git config --global https.proxy host:port<br><br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>命令中的主机号(host)是使用的代理的主机号，如果代理软件运行在本机则填入127.0.0.1即可，否则填入代理主机 ip</li><li>命令中的端口号为代理软件或代理主机的监听IP，可以从代理服务器配置中获得</li><li>socks5和http两种协议由使用的代理软件决定，不同软件对这两种协议的支持有差异，如果不确定可以都尝试一下</li></ul><p><strong>查看代理命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --get http.proxy<br>git config --global --get https.proxy<br></code></pre></td></tr></table></figure><p><strong>取消代理命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><h3 id="方法二：配置-SSH-代理"><a href="#方法二：配置-SSH-代理" class="headerlink" title="方法二：配置 SSH 代理"></a>方法二：配置 SSH 代理</h3><p class="note note-primary">使用 https 协议连接输入账号密码比较麻烦，而使用 SSH 密钥验证连接更方便且安全。可以修改系统中的 SSH 配置设置代理，并且绕过 GFW 的封锁。</p><p>Windows平台配置文件位于C:\Users$USERNAME$.ssh\config，如果没有config文件，自己创建一个config文件，其中USERNAME是当前电脑用户名。</p><h4 id="Windows-平台"><a href="#Windows-平台" class="headerlink" title="Windows 平台"></a>Windows 平台</h4><ul><li><p>Windows平台的git中预置了connect.exe，可以用来接管git的流量。可以通过修改本地SSH配置文件来更改git的代理设置。</p></li><li><p>Windows平台配置文件位于C:\Users$USERNAME$.ssh\config，如果没有config文件，自己创建一个config文件，其中USERNAME是当前电脑用户名。</p></li></ul><p>在文件中加入下面配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host github.com *.github.com <span class="hljs-comment"># 指定代理规则作用域</span><br>  User git<br>  Port 22 <span class="hljs-comment"># 端口号</span><br>  <span class="hljs-comment"># 自己的私钥所在路径</span><br>  IdentityFile <span class="hljs-string">&quot;~\.ssh\id_rsa&quot;</span><br>  <span class="hljs-comment"># SOCKS代理设置方法</span><br>  ProxyCommand connect -S 主机号:端口 %h %p<br>  <span class="hljs-comment"># HTTPS代理设置方法</span><br>  ProxyCommand connect -H 主机号:端口 %h %p<br></code></pre></td></tr></table></figure><h4 id="Linux-或-Mac-OS"><a href="#Linux-或-Mac-OS" class="headerlink" title="Linux 或 Mac OS"></a>Linux 或 Mac OS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host github.com *.github.com<br>  User git<br>  Port 22<br>  IdentityFile <span class="hljs-string">&quot;~\.ssh\id_rsa&quot;</span><br>  <span class="hljs-comment"># SOCKS代理</span><br>  ProxyCommand nc -v -x 主机号:端口 %h %p<br>  <span class="hljs-comment"># HTTPS代理</span><br>  ProxyCommand socat - PROXY:主机号:%h:%p,proxyport=端口<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>修改系统配置需要管理员权限</li><li>选择SOCKS 和 HTTPS代理需要根据代理软件支持的协议而定，二选一</li><li>如果连接局域网（内网）代理，host设置为代理服务器地址即可，端口号则设置为代理服务器端口号</li><li>如果软件在本机运行，host设置为本机（127.0.0.1）即可，端口号则设置为代理软件的监听端口号</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/wls666/article/details/123270948">git 报错Failed to connect to github.com port 443 after 21224 ms: Timed out 解决办法 - CSDN</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS协议是如何进行加密传输的</title>
    <link href="/2022/07/02/1-talk-about-https/"/>
    <url>/2022/07/02/1-talk-about-https/</url>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p class="note note-primary">HTTP 与 HTTPS 有哪些区别？</p><ol><li><p><code>HTTP</code> 是超文本传输协议，信息是明文传输，存在安全风险的问题。<code>HTTPS</code> 则解决 <code>HTTP</code> 不安全的缺陷，在<code>TCP</code> 和 <code>HTTP</code> ⽹络层之间加⼊了 <code>SSL/TLS</code> 安全协议，使得报文能够加密传输。 </p></li><li><p><code>HTTP</code> 连接建立相对简单， <code>TCP</code> 三次握手之后便可进⾏ <code>HTTP</code> 的报文传输。而 <code>HTTPS</code> 在 <code>TCP</code> 三次握手之后，还需进⾏ <code>SSL/TLS</code> 的握手过程，才可进⼊加密报文传输。 </p></li><li><p><code>HTTP</code> 的端口号是 <code>80</code>，<code>HTTPS</code> 的端口号是 <code>443</code>。 </p></li><li><p><code>HTTPS</code> 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></li></ol><p><img src="https://image.origin-tec.com/img/c582480c316a76377928f5da6bf12e96@841x404.png" alt="http协议与https协议结构示意图"></p><p class="note note-primary">HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议</p><ul><li>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li>身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁手」而没。</li></ul><blockquote><p>可见，只要自身不做「恶」，SSL&#x2F;TLS 协议是能保证通信是安全的</p></blockquote><h3 id="1-混合加密"><a href="#1-混合加密" class="headerlink" title="1. 混合加密"></a>1. 混合加密</h3><blockquote><p>通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。</p></blockquote><p><img src="https://image.origin-tec.com/img/7625e8818660455ace40e976ef35ca53@637x513.png" alt="https加密传输示意图"></p><h4 id="HTTPS-采用的是对称加密和非对称加密结合的「混合加密」方式："><a href="#HTTPS-采用的是对称加密和非对称加密结合的「混合加密」方式：" class="headerlink" title="HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式："></a>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</h4><ul><li><p>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</p></li><li><p>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</p></li></ul><h4 id="采用「混合加密」的方式的原因："><a href="#采用「混合加密」的方式的原因：" class="headerlink" title="采用「混合加密」的方式的原因："></a>采用「混合加密」的方式的原因：</h4><ul><li><p>对称加密只使用⼀个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</p></li><li><p>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</p></li></ul><h3 id="2-摘要算法"><a href="#2-摘要算法" class="headerlink" title="2. 摘要算法"></a>2. 摘要算法</h3><blockquote><p>摘要算法用来实现完整性，能够为数据生成独⼀无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p></blockquote><p><img src="https://image.origin-tec.com/img/12b4ea8cc14b8dc4de9581b921a9941a@687x269.png" alt="摘要算法"></p><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」⼀同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p><h3 id="3-数字证书"><a href="#3-数字证书" class="headerlink" title="3. 数字证书"></a>3. 数字证书</h3><blockquote><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用⾃⼰的私钥解密。</p></blockquote><p><img src="https://image.origin-tec.com/img/36411ba174f87f0aebe044f179fe07d1@692x533.png" alt="数字证书"></p><p>这就存在些问题，如何保证公钥不被篡改和信任度？</p><p>所以这⾥就需要借助第三方权威机构 CA （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p><p class="note note-primary">HTTPS 是如何建立连接的？其间交互了什么？</p><p><code>SSL/TLS</code> 协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进⾏加密通信。</li></ul><h3 id="SSL-x2F-TLS-协议建立的详细流程："><a href="#SSL-x2F-TLS-协议建立的详细流程：" class="headerlink" title="SSL&#x2F;TLS 协议建立的详细流程："></a>SSL&#x2F;TLS 协议建立的详细流程：</h3><h4 id="1-ClientHello"><a href="#1-ClientHello" class="headerlink" title="1. ClientHello"></a>1. ClientHello</h4><blockquote><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。 在这⼀步，客户端主要向服务器发送以下信息： </p></blockquote><p>（1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。<br>（2）客户端生产的随机数（ <code>Client Random</code> ），后面用于生产「会话秘钥」。<br>（3）客户端支持的密码套件列表，如 RSA 加密算法。 </p><h4 id="2-SeverHello"><a href="#2-SeverHello" class="headerlink" title="2. SeverHello"></a>2. SeverHello</h4><blockquote><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code> 。服务器回应的内容有如下内容： </p></blockquote><p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。<br>（2）服务器生产的随机数（ <code>Server Random</code> ），后面用于生产「会话秘钥」。<br>（3）确认的密码套件列表，如 RSA 加密算法。<br>（4）服务器的数字证书。 </p><h4 id="3-客户端回应"><a href="#3-客户端回应" class="headerlink" title="3. 客户端回应"></a>3. 客户端回应</h4><blockquote><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。<br>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息： </p></blockquote><p>（1）⼀个随机数（ <code>pre-master key</code> ）。该随机数会被服务器公钥加密。<br>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。上面第⼀项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各⾃生成本次通信的「会话秘钥」。</p><h4 id="4-服务器的最后回应"><a href="#4-服务器的最后回应" class="headerlink" title="4. 服务器的最后回应"></a>4. 服务器的最后回应</h4><blockquote><p>服务器收到客户端的第三个随机数（ <code>pre-master key</code> ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息： </p></blockquote><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这⼀项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。⾄此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使用普通的 HTTP协议，只不过用「会话秘钥」加密内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/qq_34827674/article/details/124089736">图解网络 - 小林Coding - CSDN</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术杂谈</category>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTPS</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
